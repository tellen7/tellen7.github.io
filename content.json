[{"title":"Ubuntu安装docker","date":"2017-04-27T10:51:57.000Z","path":"2017/04/27/Ubuntu安装docker/","text":"简要步骤step 1 wget -qO- https://get.docker.com/ | sh结果如下 note 我个人在ubuntu虚拟机中实验，32位的安装docker时，执行该命令有问题。什么i836的。64为的没有问题。 在结果图中，更改docker运行用户的问题，不改的话，如果执行docker run hello-world时会有问题 docker: Cannot connect to the Docker daemon. Is …报了docker守护线程没有开启，用ps -ef看了下是开启的。其实是用sudo docker run命令才对，不过还是有点问题。 step 21sudo usermod -aG docker (yourUsername) step 312wyh@ubuntu:~$ sudo service docker startwyh@ubuntu:~$ sudo docker run hello-world 运行结果： 最后附上关闭docker服务的命令sudo service docker stop","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Ubuntu16.04 install LAMP","date":"2017-04-25T13:47:56.000Z","path":"2017/04/25/Ubuntu16-04-install-LAMP/","text":"linux下开发必备环境 安装apache2 1sudo apt-get install apache2 安装结果 /etc/apache2/ |-- apache2.conf | `-- ports.conf |-- mods-enabled | |-- *.load | `-- *.conf |-- conf-enabled | `-- *.conf |-- sites-enabled | `-- *.conf 项目文件在/var/www/ 启动apache2服务 service apache2 start 打开浏览器，打开http://127.0.0.1/进行验证 安装php7 12345678sudo apt-get install php7.0 sudo apt-get install libapache2-mod-php7.0 // 配置APACHE+PHP7的sudo apt-get install libapache2-mod-php // 这个应该是配置APACHE+PHP5的，一块装吧sudo /etc/init.d/apache2 restart // 重启 在项目目录里创建测试文件test.php内容如下： hello php &lt;?php phpinfo(); ?&gt; 浏览器打开http://127.0.0.1/test.php进行验证 -安装mysql1apt-get install mysql-server mysql-client notemysql-server：用来创建和管理数据库实例，提供相关接口供不同客户端调用;mysql-client：操作数据库实例的的一个命令行工具，像图形化界面工具有phpmyadmin等;mysqld：即MySQL servermysql：即mysql-client客户端命令行工具 启动服务service mysql start 验证是否开启mysql服务 ps -ef | grep mysql ps：自启动管理工具 apt-get install sysv-rc-conf","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"使用git的基本式jgit的基本（优雅）方式“","date":"2017-04-21T15:17:55.000Z","path":"2017/04/21/使用git的基本式jgit的基本（优雅）方式“/","text":"从开始使用git到养成习惯，就是这么简单先上图表示一下基本流程 首先下载git for windows,直接安装。 添加SSH KEY，在github上“setting”里面按照步骤进行。 在github上创建一个仓库，例如test。 在本地的项目（test项目）文件夹下右键Git bash here。 输入 git init，这个命令会在项目目录下生成一个.git的目录，这里面存放的就是项目的版本库和git配置文件。 为了利用github给你智能生成的.gitignore和readme.md文件，先将github上的仓库pull一下，在git bash终端输入git pull https://github.com/~~~/test.git 添加项目更新，git add . 提交项目更新，git commit -m “first time commit” 建立远程仓库，git remote add origin https://github.com/~~~/test.git push更新，git push -u origin master 这样本地仓库就与github上面仓库建立联系啦，以后就可以愉快的玩耍了。 PS：下面附赠git常用命令行","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"spring基于@Value绑定属Bean性失","date":"2017-04-20T09:34:52.000Z","path":"2017/04/20/spring基于-Value绑定属Bean性失/","text":"用spring注解@Value绑定属性失败环境： eclipse Version: Luna Release (4.4.0) spring 4.0 Junit4 其他依赖包 描述：JsrDAO类，在该类中使用了SpEL和spring注解12345678910111213141516171819202122232425262728293031323334package com.laowang.annotationBase;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.ImportResource;import org.springframework.stereotype.Repository;@Repository(\"dao\")@ImportResource(\"classpath*:jdbc.properties\")public class JsrDAO &#123; @Value(\"$&#123;url&#125;\")//加载配置文件中key为url的value值注入 private String url; @Value(\"$&#123;name&#125;\") private String name; @Value(\"$&#123;password&#125;\") private String password; public void save()&#123; System.out.println(\"jsr saving...\"); System.out.println(\"url: \"+url); System.out.println(\"name: \"+name); System.out.println(\"password: \"+password); &#125; public void init()&#123; System.out.println(\"init jsrDAO Bean ...\"); &#125; public void destroy()&#123; System.out.println(\"destroy jsrDAO Bean ...\"); &#125;&#125; 资源文件内容 url=http\\://localhost\\:3306/database name=root password=root JavaConfig类，Bean的装配工作12345678910111213141516package com.laowang.annotationBase;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;import org.springframework.test.context.ContextConfiguration;@Configurationpublic class JavaConfig &#123; @Bean(name=\"dao\", initMethod=\"init\", destroyMethod=\"destroy\") public JsrDAO getJseDAO()&#123; return new JsrDAO(); &#125;&#125; 测试类1234567891011121314151617181920package com.laowang.annotationBase;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=JavaConfig.class)public class TestA &#123; @Autowired private JsrDAO jsDao; @Test public void testDAO()&#123; jsDao.save(); &#125;&#125; 结果获得数据显示为 init jsrDAO Bean ... jsr saving... url: ${url} name: ${name} password: ${password} destroy jsrDAO Bean ... 问题出现在用SpEL占位符绑定bean的三个属性没有成功，正确的结果应该是这样的 init jsrDAO Bean ... jsr saving... url: http://localhost:3306/database name: root password: root destroy jsrDAO Bean ... 问题出现在哪里呢？按理说应该不会错的。于是百度、谷歌搜索，都没解决，最后去了spring官方文档看到正确使用方式 所以只需要修改JavaConfig文件就可以了，添加一行注解，变成如下： 1234567891011121314151617181920212223package com.laowang.annotationBase;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(\"classpath*:spring-annotationBase.xml\")//这个必须要引入，否者得到配置文件中的值是有问题的，有了这个可以不用在JsrDAO中重配置了，多了也无妨public class JavaConfig &#123; @Bean(name=\"dao\", initMethod=\"init\", destroyMethod=\"destroy\") public JsrDAO getJseDAO()&#123; return new JsrDAO(); &#125; @Bean public JsrService getJsrService()&#123; JsrService service =new JsrService(); service.setJsrDAO(getJseDAO()); return service; &#125; &#125; 同时再添加一个对应的xml配置文件，指定属性配置文件的位置，此时JsrDAo中属性文件位置的指定也可以不用了。下面是对应的xml文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:/properties/jdbc.properties\"/&gt;&lt;/beans&gt; PS：下面补充一点知识关于代理模式，如图 运行时注入 属性占位符（Property Placeholder） Spring 表达式语言SpEL 属性占位符（Property Placeholder） 加载资源配置文件后，通过环境对象（Environment）env获取配置文件内容，如1env.getProperty(\"jdbc.name\"); 具体使用要参考文档 解析属性占位符一般使用SpEL语言SpEL语言特性如下： 使用bean的ID来引用bean 调用方法和访问对象的属性 对值进行算术、关系和逻辑运算 正则表达式匹配 集合操作 详 “#{…}”=======表达式“${…}”=======占位符 字面常量“#{1}”=======计算结果为1 引用bean、属性和方法“#{bean}”=======引用bean“#{bean.attr}”=======计算得到（引用）bean的属性“#{systemProperties[‘jdbc.name’]}”=======通过systemProperties对象引用系统属性（个人理解为引用形同加载配置文件中的属性的值）“#{bean.method()}”=======调用bean的方法“#{bean.method()?.toUpperCase()}”=======方法返回不为空时继续调用toUpperCase()，否则不调用 在表达式中使用类型“#{T(java.lang.Math).random}”=======只能调用类的静态方法和常量 SpEL 运算符不说了 计算正则表达式：文本（matches）正则表达式“#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com’}”=======邮件验证 计算集合“#{bean.list[2].attr}”=======获取bean中结合list第3个元素的attr属性 SpEL 其他运算符 （.?[]）对集合进行过滤。[]里面是表达式“#{bean.list.?[attr eq ‘laowang’]}” .^[] 集合中查询第一个匹配项 .$[] 集合中查询最后一个匹配项","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring Bean","date":"2017-04-14T01:00:04.000Z","path":"2017/04/14/Spring-Bean/","text":"Spring Bean的相关基础知识先上图： bean的配置 Id bean的唯一标识 *必须 Class 具体实现类 *必须 Scope 作用域范围 singleton ：单例，一个bean容器只存在一份 prototype ：每次请求创建新实例，destroy方式不生效 request ：每次http请求创建一个实例且仅在当前request内有效 session ：同上 global session ：基于protlet的web中有效（portlet中定义了global session），如果在web中，同session Constructor arguments 构造器（构造函数），参数 Properties 属性 Autowiring mode 自动装配模式 lazy-initialization mode 懒加载模式 initialization/destruction method 初始化方法/销毁方法 等… … bean的作用域 singleton ：单例，一个bean容器只存在一份 prototype ：每次请求创建新实例，destroy方式不生效 request ：每次http请求创建一个实例且仅在当前request内有效 session ：同上 global session ：基于protlet的web中有效（portlet中定义了global session），如果在web中，同session bean的生命周期上图： 接下来： 定义 初始化 1.设置全局的初始化方法default-init-method或对单个bean设置init-method 2.实现org.sringframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 使用 销毁 1.设置全局的销毁方法default-destroy-method或对单个bean设置destroy-method 2.实现org.sringframework.beans.factory.DisposeableBean接口，覆盖destroy方法 bean的自动装配 Spring中提供了一些一Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应的资源。 通过Aware接口可以对spring相应资源进行操作 设置默认自动装配，spring容器中就不需要再为bean手动设置属性引用关系，容器会自动寻找和bean属性名相同的bean的id，并且自动完成bean的装配： 123456789101112 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"default-autowire=\"byName\"&gt;&lt;bean id=\"injectionDao\" class=\"com.laowang.dao.InjectionDAOImp\"/&gt;&lt;bean id=\"injectionservice\" class=\"com.laowang.service.InjectionServiceImp\"/&gt;&lt;!-- &lt;property name=\"injectiondao\" ref=\"injectionDao\"&gt;&lt;/property&gt;通过设置自动装配，就不用单独为bean装配了 --&gt;&lt;/beans&gt; Resource&amp;ResourceLoader 下面是resourceLoader resourceloader加载文件的location类型 //第一次更新。最近读了spring实战，对spring bean的配置又多了一点知识储备。 装配bean有三种机制 基于xml配置显示的装配bean 基于javaConfig的配置类(@Configuration)显示装配bean 隐式的bean发现机制和自动装配(需要@Configuration和@ComponentScan) 关于第三种机制的使用规制 12345678//spring配置之隐式bean发现和自动装配@Configuration@ComponentScan//也可用Named替换,默认扫面package包内注解//@ComponentScan(basePackages=&#123;\"com.laowang.chapter02\"&#125;)指定扫描的package//@ComponentScan(basePackageClasses=&#123;Cd.class,UseCd.class&#125;)指定扫描的类//@ImportResource(\"classpath:spring-beans.xml\")//public class Config &#123;&#125; 关于第二种机制的使用例子123456789101112131415161718192021222324@Configurationpublic class javaConfig &#123;//只是用@Bean话，bean的id将会初始化为方法名@Bean(name=\"cd\")public Cd getCd()&#123; return new Cd();&#125;//通过setter方法自动装配bean引用@Bean(name=\"useCd\")public UseCd randomMentod()&#123; UseCd useCd = new UseCd(); useCd.setCd(getCd()); return useCd;&#125;//通过构造器自动装配bean// @Bean(name=\"useCd\")// public UseCd getByConstructor()&#123;// return new UseCd(getCd());// &#125;&#125; 关于第一种使用规则就比较多了，需要的时候再搜索吧 接下来是基础的spring bean的注解 @Component 该类作为组建类，告知spring为这个类创建bean @Named//bean命名 @Configuration @ComponentScan @Bean @Import @ImportResource @Inject//注入 @Autowired @ContextConfiguration//从哪加载配置 @Repositroy （PS：下面是web.xml配置文件的详解） web.xml配置详解","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"单例模式优化详解","date":"2017-04-02T02:26:35.000Z","path":"2017/04/02/单例模式优化详解/","text":"在GoF的23种设计模式中，单例模式是比较简单的一种。然而，有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。 1. 最简单的实现 首先，能够想到的最简单的实现是，把类的构造函数写成private的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。这样，使用者就可以通过这个引用使用到这个类的实例了。 public class SingletonClass { private static final SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() { return instance; } private SingletonClass() { } } 如上例，外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 2. 性能优化——lazy loaded 上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个instance对象。如果这个创建过程很耗时，比如需要连接10000次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？ 为了解决这个问题，我们想到了新的解决方案： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。 我们来想象一下这个过程。要使用SingletonClass，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。 这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载。 3. 同步 上面的代码很清楚，也很简单。然而就像那句名言：“80%的错误都是由20%代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下： 线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败！ 解决的方法也很简单，那就是加锁： public class SingletonClass { private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 是要getInstance()加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。 4. 又是性能 上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题——synchronized修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } return instance; } private SingletonClass() { } } 首先去掉getInstance()的同步操作，然后把同步锁加载if语句上。但是这样的修改起不到任何作用：因为每次调用getInstance()的时候必然要同步，性能问题还是存在。如果……如果我们事先判断一下是不是为null再去同步呢？ public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if (instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } } 还有问题吗？首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。 这就是double-checked locking设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。 5. 从源头检查 下面我们开始说编译原理。所谓编译，就是把源代码“翻译”成目标代码——大多数是指机器代码——的过程。针对Java，它的目标代码不是本地机器代码，而是虚拟机代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程成为reorder。 要知道，JVM只是一个标准，并不是实现。JVM中并没有规定有关编译器优化的内容，也就是说，JVM实现可以自由的进行编译器优化。 下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM规范并没有规定。那么就存在这么一种情况，JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。 下面我们来考虑这么一种情况：线程A开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，A已经把instance指向了那块内存，只是还没有调用构造方法，因此B检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果B在A将instance构造完成之前就是用了这个实例，程序就会出现错误了！ 于是，我们想到了下面的代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { SingletonClass sc; synchronized (SingletonClass.class) { sc = instance; if (sc == null) { synchronized (SingletonClass.class) { if(sc == null) { sc = new SingletonClass(); } } instance = sc; } } } return instance; } private SingletonClass() { } } 我们在第一个同步块里面创建一个临时变量，然后使用这个临时变量进行对象的创建，并且在最后把instance指针临时变量的内存空间。写出这种代码基于以下思想，即synchronized会起到一个代码屏蔽的作用，同步块里面的代码和外部的代码没有联系。因此，在外部的同步块里面对临时变量sc进行操作并不影响instance，所以外部类在instance=sc;之前检测instance的时候，结果instance依然是null。 不过，这种想法完全是错误的！同步块的释放保证在此之前——也就是同步块里面——的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把instance=sc;这句移到内部同步块里面执行。这样，程序又是错误的了！ 6. 解决方案 说了这么多，难道单例没有办法在Java中实现吗？其实不然！ 在JDK 5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。 public class SingletonClass { private volatile static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } } 然而，这只是JDK1.5之后的Java的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到Java版本的影响： public class SingletonClass { private static class SingletonClassInstance { private static final SingletonClass instance = new SingletonClass(); } public static SingletonClass getInstance() { return SingletonClassInstance.instance; } private SingletonClass() { } } 在这一版本的单例模式实现代码中，我们使用了Java的静态内部类。这一技术是被JVM明确说明了的，因此不存在任何二义性。在这段代码中，因为SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。 由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是并发的，所以getInstance()也并不需要加同步。 至此，我们完整的了解了单例模式在Java语言中的时候，提出了两种解决方案。个人偏向于第二种，并且Effiective Java也推荐的这种方式。 转载自tuoni123的博客","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"spring初识","date":"2017-03-27T14:30:42.000Z","path":"2017/03/27/spring初识/","text":"Spring 概述 1. Spring 是什么Spring 是一个开源的轻量级 Java SE（ Java 标准版本）/Java EE（ Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。 Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA ），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 web 层框架 Spring MVC 、而且还能非常简单的与第三方 web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（ C/S 架构）应用程序还是 JAVA EE（ B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？ 2. Spring 能帮我们做什么2.1. Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系 传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。 2.2 Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制 当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring ，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。 2.3 Spring能非常简单的帮我们管理数据库事务 在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。 除以上之外，Spring 还可以： 与第三方数据库访问框架（如 Hibernate、JPA ）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。 与第三方 Web（如 Struts、JSF ）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 web 层搭建。 与 Java EE（如 Java Mail 、任务调度）整合，与更多技术整合（比如缓存框架）。 3. Spring 的优点3.1 关键概念 应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。 框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。 轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 POJO ： POJO （ Plain Ordinary Java Object ）简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 控制反转：即 Inversion of Control ，缩写为 IoC ，控制反转还有一个名字叫做依赖注入（ Dependency Injection ），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。 - Bean ：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。 3.2 Spring 的优点 非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 JAR 包非常小，Spring3.0.5 不到 1 M ，而且不需要依赖任何应用服务器，可以部署在任何环境（ Java SE 或 Java EE ）。 AOP： AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（ OOP ），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。 简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。 JDBC 抽象及 ORM （对象关系映射）框架支持： Spring 使 JDBC 更加容易使用；提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等；并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。 灵活的 Web 层支持： Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。 简化各种技术集成：提供对 Java Mail 、任务调度、 JMX 、 JMS 、 JNDI 、 EJB 、动态语言、远程访问、 Web Service 等的集成。 Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。 4. Spring 架构图 4.1核心容器：包括 Core 、 Beans 、 Context 、 EL 模块 Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。 Beans 模块：提供了框架的基础部分，包括控制反转（ IOC ）和依赖注入（ DI ）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。 Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、 Java EE 支持、容器生命周期、事件传播等；核心接口是 ApplicationContext 。 EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean， 它也支持列表投影、选择和一般的列表聚合等. 4.2 AOP 、 Aspects 模块： AOP 模块： Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（ aspect-oriented programming ）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。数据访问/集成模块：该模块包括了 JDBC 、 ORM 、 OXM 、 JMS 和事务管理。 事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。 JDBC 模块：提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。 ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate 、JPA 、 MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。 OXM 模块：提供了一个对 Object / XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象， Object / XML 映射实现包括 JAXB 、 Castor 、 XMLBeans 和 XStream 。 JMS 模块：用于 JMS ( Java Messaging Service )，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS ， JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Web / Remoting 模块： Web / Remoting 模块包含了 Web 、 Web-Servlet 、 Web-Struts 、 Web-Porlet 模块。 Web 模块：提供了基础的 web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（ RMI 、Hessian 、 Burlap ）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。 Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。 Web-Struts 模块：提供了与 Struts 无缝集成， Struts1.x 和 Struts2.x 都支持。 Test 模块： Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"succeed_in_build_nginx_module","date":"2017-03-22T13:31:34.000Z","path":"2017/03/22/succeed-in-build-nginx-module/","text":"开发nginx入门竟然成功了，下面就是我的路程向上图说明一下nginx模块工作流程 工具准备 ubuntu虚拟机 nginx源文件 *Note 鉴于博客是我自己看我就只是记录一些关键步骤 Nginx在Linux下的安装与运行tar -zxvf archive_name.tar.gz 解压文件命令 编译安装原文件用以下命令 ./configure --prefix=/usr/local/nginx make make install *note 这里给出编译安装nginx中使用到的命令 --prefix=指定安装目录 --add-module=连带模块一起便已安装的模块路径 模块的目录结构是module.c以及config文件 安装完成后可以直接使用下面命令启动Nginx： /usr/local/nginx/sbin/nginx Nginx默认以Deamon进程启动，输入下列命令： curl -i http://localhost/ 就可以检测Nginx是否已经成功运行。或者也可以在浏览器中输入http://localhost/，应该可以看到Nginx的欢迎页面了。启动后如果想停止Nginx可以使用： /usr/local/nginx/sbin/nginx -s stop 开发模块源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148 #include&lt;ngx_config.h&gt;#include&lt;ngx_core.h&gt;#include&lt;ngx_http.h&gt;//定义模块配置结构typedef struct&#123; ngx_str_t ed;//用于存储echo指令指定输出字符串&#125;ngx_http_echo_loc_conf_t;//函数声明static char *ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);static void *ngx_http_echo_create_loc_conf(ngx_conf_t *cf);static char *ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child);//定义指令static ngx_command_t ngx_http_echo_commands[]=&#123;&#123; ngx_string(\"echo\"), NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1, ngx_http_echo, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_echo_loc_conf_t, ed), NULL&#125;,ngx_null_command//指令数组最后一个结尾元素&#125;;//模块echo的context结构配置 static ngx_http_module_t ngx_http_echo_module_ctx=&#123; NULL, //pre configuration NULL, //post configuration NULL, //create main configuration NULL, //init main configuration NULL, //create server configuration NULL, //merge server configuration ngx_http_echo_create_loc_conf, //create location configuration ngx_http_echo_merge_loc_conf //merge location configuration&#125;;//echo模块的模块主体定义ngx_module_t ngx_http_echo_module = &#123; NGX_MODULE_V1, &amp;ngx_http_echo_module_ctx, /* module context */ ngx_http_echo_commands, /* module directives*/ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING&#125;;/**模块的handler函数编写.主要有4个职责* 读入模块配置* 处理业务功能* 产生HTTP Header* 产生HTTP body*/static ngx_int_t ngx_http_echo_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_buf_t *b; ngx_chain_t out; ngx_http_echo_loc_conf_t *elcf; elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module); if(!(r-&gt;method &amp; (NGX_HTTP_HEAD | NGX_HTTP_GET | NGX_HTTP_POST))) &#123; return NGX_HTTP_NOT_ALLOWED; &#125; r-&gt;headers_out.content_type.len = sizeof(\"text/html\")-1; r-&gt;headers_out.content_type.data = (u_char *)\"text/html\"; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = elcf-&gt;ed.len; if(r-&gt;method == NGX_HTTP_HEAD) &#123; rc = ngx_http_send_header(r); if(rc != NGX_OK) &#123; return rc; &#125; &#125; b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t)); if(b == NULL) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"Fail to allocate response buffer.\"); return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; out.buf = b; out.next = NULL; b-&gt;pos = elcf-&gt;ed.data; b-&gt;last = elcf-&gt;ed.data + (elcf-&gt;ed.len); b-&gt;memory =1; b-&gt;last_buf = 1; rc = ngx_http_send_header(r); if(rc != NGX_OK) &#123; return rc; &#125; return ngx_http_output_filter(r, &amp;out);&#125;//指令中函数指针的实现static char* ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_echo_handler; ngx_conf_set_str_slot(cf, cmd, conf); return NGX_CONF_OK;&#125;//初始化一个配置结构体static void* ngx_http_echo_create_loc_conf(ngx_conf_t *cf)&#123; ngx_http_echo_loc_conf_t *conf; conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_echo_loc_conf_t)); if(conf == NULL) &#123; return NGX_CONF_ERROR; &#125; conf-&gt;ed.len = 0; conf-&gt;ed.data = NULL; return conf;&#125;//合并配置结构体(将父类配置信息合并到此)static char* ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent,void *child)&#123; ngx_http_echo_loc_conf_t *pre = parent; ngx_http_echo_loc_conf_t *conf = child; ngx_conf_merge_str_value(conf-&gt;ed, pre-&gt;ed, \"\")//具体合并的实现是一个宏定义 return NGX_CONF_OK;&#125; Nginx模块的安装Nginx不支持动态链接模块，所以安装模块需要将模块代码与Nginx源代码进行重新编译。安装模块的步骤如下： 1、编写模块config文件，这个文件需要放在和模块源代码文件放在同一目录下。文件内容如下： ngx_addon_name=模块完整名称 HTTP_MODULES=&quot;$HTTP_MODULES 模块完整名称&quot; NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/源代码文件名&quot; 2、进入Nginx源代码，使用下面命令编译安装 ./configure --prefix=安装目录 --add-module=模块源代码文件目录 make make install 这样就完成安装了，例如，我的源代码文件放在/home/yefeng/ngxdev/ngx_http_echo下，我的config文件为： ngx_addon_name=ngx_http_echo_module HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_echo_module&quot; NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_echo_module.c&quot; 编译安装命令为： ./configure --prefix=/usr/local/nginx --add-module=/home/laowang/ngxdev/ngx_http_echo make sudo make install 这样echo模块就被安装在我的Nginx上了，下面测试一下，修改配置文件，增加以下一项配置： location /echo { echo &quot;This is my first nginx module!!!&quot;; } 然后用curl测试一下： curl -i http://localhost/echo 这里附上此次在ubuntu上用到的命令行 ps -ef |grep nginx 查看nginx的进程 nginx -s reload 重新加载nginx的配置文件 pwd 查看当前工作路径 提醒 本次实践完全是在root环境下的，整个过程很多地方都用sudo 再接再厉参考博客","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginxNote","date":"2017-03-19T15:47:57.000Z","path":"2017/03/19/nginxNote/","text":"Nginx模块开发笔记预备知识1.C语言的结构体和预处理命令以及指针相关知识。 2.HTTP协议的基本了解。 3.Nginx的基本配置 Nginx 配置文件主要分成四部分： main（全局设置）、 server（主机设置） 、upstream（上游服务器设置）和location（URL匹配特定位置后的设置） 。 每部分包含若干个指令。 main 部分设置的指令将影响其它所有部分； server 部分的指令主要用于指定主机和端口； upstream 的指令用于设置后端服务器；location 部分用于匹配网页位置（比如， 根目录“/”,“/images” 等等） 。Location 部分会继承 server 部分的指令，而 server 部分的指令会继承 main 部分； upstream 既不继承指令也不会影响其他部分。 它有自己的特殊指令，不需要在其他地方的应用。 Nginx 模块主要有 3 种角色 handlers(处理模块) 用于处理 HTTP 请求， 然后产生输出 filters（过滤模块） 过滤 handler 产生的输出 load-balancers（负载均衡模块） 当有多于一台的后端备选服务器时， 选择一台转发 HTTP 请求 一个典型的处理周期是这样的 客户 端发送 HTTP 请求-&gt;Nginx 根据配置选择一个合适的处理模块-&gt;（如果有）负载均衡模块选择一台后端服务器，并负责完成后端的发送接收过程-&gt;处理模块进行处理并把输出缓冲放到第一个过滤模块上-&gt;第一个过滤模块处理后输出给第二个过滤模块-&gt;然后第二个过滤模块又到第三个-&gt;依此类推-&gt;最后把回复发给客户 端。 Nginx启动，关闭，重启看这个博客 Nginx模块开发入门博客比较好的一篇博客 还有一个不错的博客","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"PythonNote","date":"2017-03-19T07:00:39.000Z","path":"2017/03/19/PythonNote/","text":"python note1.Python的字符串对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： &gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;中&apos;) 20013 &gt;&gt;&gt; chr(66) &apos;B&apos; &gt;&gt;&gt; chr(25991) &apos;文&apos; 输出 &gt;&gt;&gt; &apos;\\u4e2d\\u6587&apos; &apos;中文&apos; 2.常见的占位符%d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 NOTE 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： &gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7 &apos;growth rate: 7 %&apos; 返回多个值输入 import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 输出 &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(x, y) 151.96152422706632 70.0 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 默认参数必须指向不变对象例如 def add_end(L=[]): L.append(&apos;END&apos;) return L &gt;&gt;&gt; add_end() [&apos;END&apos;, &apos;END&apos;] &gt;&gt;&gt; add_end() [&apos;END&apos;, &apos;END&apos;, &apos;END&apos;] 原因:Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 修改 def add_end(L=None): if L is None: L = [] L.append(&apos;END&apos;) return L 可变参数的函数def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，可以这样做： &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 函数小结 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 切片&gt;&gt;&gt; L = list(range(100)) &gt;&gt;&gt; L [0, 1, 2, 3, ..., 99] 前10个数： &gt;&gt;&gt; L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： &gt;&gt;&gt; L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： &gt;&gt;&gt; L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： &gt;&gt;&gt; L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list： &gt;&gt;&gt; L[:] [0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： &gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： &gt;&gt;&gt; &apos;ABCDEFG&apos;[:3] &apos;ABC&apos; &gt;&gt;&gt; &apos;ABCDEFG&apos;[::2] &apos;ACEG&apos; 迭代 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 判断一个对象是可迭代对象的方法是通过collections模块的Iterable类型判断： &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： &gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): ... print(i, value) ... 0 A 1 B 2 C 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： &gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]: ... print(x, y) ... 1 1 2 4 3 9 列表解析 &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： &gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到 &gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录 [&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] 列表生成式也可以使用两个变量来生成list： &gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; } &gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()] [&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写： &gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;] &gt;&gt;&gt; [s.lower() for s in L] [&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 函数是编程 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。 Python内建map()和reduce()函数&gt;&gt;&gt; def f(x): ... return x * x ... &gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串： &gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] 装饰器在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。 装饰器","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"梦之光芒小游戏","date":"2017-01-15T06:38:48.000Z","path":"2017/01/15/梦之光芒小游戏/","text":"第一关查看源代码即可 第二关 第三关 第四关先将string.fromCharCode()翻译过来 翻译过后能看到答案d4g","tags":[{"name":"闯关游戏","slug":"闯关游戏","permalink":"http://yoursite.com/tags/闯关游戏/"}]},{"title":"jsp传递bean到servlet为null","date":"2016-12-12T15:34:10.000Z","path":"2016/12/12/jsp传递bean到servlet为null/","text":"jsp 中使用 1&lt;jsp:useBean id=\"user\" scope=\"request\" class=\"bean.User\"&gt; id是bean的引用名（绑定的名字） scope作用域（request|session|application） class对象所属类的完全限定名 问题： 在jsp中使用上述方法，在servlet中获得的user 为null原因分析 jsp的编译完以后就是servlet，显示完成那个jsp页面完了以后，就已经是一次request了。因此在jsp中创建一个scope=”request”的bean只能在 jsp中、或者是jsp通过传递方式给其他对象才能用这个bean即使你jsp中提交的表单给另外一个servlet的，那已经是第二次request。对应的解决就是更改作用域范围为session。 jsp页面中javabean的属性设置是依靠 jsp engine帮你实现的。如果表单提交到了servlet，意味着你就失去了jsp engine这个优势，需要自己set这些属性。 如果提交给servlet，是在servlet中set这些属性。那么形成表单的页面的jsp文件中就没有必要用javabean。javabean的用法是在提交以后的那个页面，而非形成表单的页面，除非要显示或者计算用途 解决方法 方法一 设置作用域scope为session 在servlet中设置user的各个属性 在servlet中再将user绑定到session，在后就可以转发 方法二 在表单提交中不是用useBean","tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"tomcatstartup","date":"2016-11-28T14:58:14.000Z","path":"2016/11/28/tomcatstartup/","text":"启动tomcat报错Error deploying configuration descriptor 导致原因 servlet创建时有 @WebServlet(“/UploadFile”) 这个注解导致报错 报错图片","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"tomcatinstall","date":"2016-10-02T01:29:17.000Z","path":"2016/10/02/tomcatinstall/","text":"安装和配置tomcat的小坑1.下载tomcat去这个tomcat.apache.org网址下载core的zip包 2.安装tomcat将下载的tomcat解压缩就安装成功了 3.1windows下tomcat的配置设置环境变量 CATALINA_HOME C:\\Users\\wangyonghao8\\Desktop\\java文档\\tomcat\\apache-tomcat-7.0.72 note * 1.注意环境变量设置的路径是安装tomcat的路径，不是其下的bin目录 2.必须确保jdk配置成功才能成功启动tomcat 3.2eclipse下安装tomcata.打开eclipsewindows -&gt; preference -&gt; server -&gt; runtime Environment b.选择add按钮，选择对应的tomcat安装，然后选择Edit选择tomcat # 安装目录 # 4。启动tomcatwidows下直接到安装目录下的bin目录中打开startup.bat即可 eclipse中打开server视图，右击选择启动按钮即可","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"java中的堆和栈","date":"2016-09-25T01:24:03.000Z","path":"2016/09/25/java中的堆和栈/","text":"Java栈与堆—-对这两个概念的不明好久，终于找到一篇好文，拿来共享 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：复制内容到剪贴板代码:int a = 3;int b = 3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 4. String是一个特殊的包装类数据。即可以用String str = new String(“abc”);的形式来创建，也可以用String str = “abc”；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = “abc”；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。 关于String str = “abc”的内部工作。Java内部将此语句转化为以下几个步骤： (1)先定义一个名为str的对String类的对象引用变量：String str； (2)在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并返回o的地址。 (3)将str指向对象o的地址。 值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！ 为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”;System.out.println(str1==str2); //true注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。 我们再来更进一步，将以上代码改成：复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”;str1 = “bcd”;System.out.println(str1 + “,” + str2); //bcd, abcSystem.out.println(str1==str2); //false这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。 再修改原来代码：复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”; str1 = “bcd”; String str3 = str1;System.out.println(str3); //bcd String str4 = “bcd”;System.out.println(str1 == str4); //truestr3这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。 我们再接着看以下的代码。复制内容到剪贴板代码:String str1 = new String(“abc”);String str2 = “abc”;System.out.println(str1==str2); //false 创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 String str1 = “abc”;String str2 = new String(“abc”);System.out.println(str1==str2); //false创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。 7. 结论与建议： (1)我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。 (2)使用String str = “abc”；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 (3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 (4)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JavaThread","date":"2016-09-25T01:09:39.000Z","path":"2016/09/25/JavaThread/","text":"Java 线程池的原理与实现最近在学习线程池、内存控制等关于提高程序运行性能方面的编程技术，在网上看到有一哥们写得不错，故和大家一起分享。 [分享]Java 线程池的原理与实现 这几天主要是狂看源程序，在弥补了一些以前知识空白的同时，也学会了不少新的知识（比如 NIO），或者称为新技术吧。线程池就是其中之一，一提到线程，我们会想到以前《操作系统》的生产者与消费者，信号量，同步控制等等。一提到池，我们会想到数据库连接池，但是线程池又如何呢？ 建议：在阅读本文前，先理一理同步的知识，特别是syncronized同步关键字的用法。关于我对同步的认识，要缘于大三年的一本书，书名好像是 Java 实战，这本书写得实在太妙了，真正的从理论到实践，从截图分析到.class字节码分析。哇，我想市场上很难买到这么精致的书了。作为一个Java爱好者，我觉得绝对值得一读。我对此书印象最深之一的就是：equal()方法，由浅入深，经典！还有就是同步了，其中提到了我的几个编程误区，以前如何使用同步提高性能等等，通过学习，使我对同步的认识进一步加深。 简单介绍 创建线程有两种方式：继承Thread或实现Runnable。Thread实现了Runnable接口，提供了一个空的run()方法，所以不论是继承Thread还是实现Runnable，都要有自己的run()方法。 一个线程创建后就存在，调用start()方法就开始运行（执行run()方法），调用wait进入等待或调用sleep进入休眠期，顺利运行完毕或休眠被中断或运行过程中出现异常而退出。 wait和sleep比较： sleep方法有：sleep(long millis)，sleep(long millis, long nanos)，调用sleep方法后，当前线程进入休眠期，暂停执行，但该线程继续拥有监视资源的所有权。到达休眠时间后线程将继续执行，直到完成。若在休眠期另一线程中断该线程，则该线程退出。 wait方法有：wait()，wait(long timeout)，wait(long timeout, long nanos)，调用wait方法后，该线程放弃监视资源的所有权进入等待状态； wait()：等待有其它的线程调用notify()或notifyAll()进入调度状态，与其它线程共同争夺监视。wait()相当于wait(0)，wait(0, 0)。 wait(long timeout)：当其它线程调用notify()或notifyAll()，或时间到达timeout亳秒，或有其它某线程中断该线程，则该线程进入调度状态。 wait(long timeout, long nanos)：相当于wait(1000000*timeout + nanos)，只不过时间单位为纳秒。 线程池： 多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。 假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。 一个线程池包括以下四个基本组成部分： 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务； 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子： 假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324/** 线程池类，工作线程作为其内部类 **/package org.ymcn.util;import java.util.Collections;import java.util.Date;import java.util.LinkedList;import java.util.List;import org.apache.log4j.Logger;/*** 线程池* 创建线程池，销毁线程池，添加新任务* * @author obullxl*/public final class ThreadPool &#123; private static Logger logger = Logger.getLogger(ThreadPool.class); private static Logger taskLogger = Logger.getLogger(\"TaskLogger\"); private static boolean debug = taskLogger.isDebugEnabled(); // private static boolean debug = taskLogger.isInfoEnabled(); /* 单例 */ private static ThreadPool instance = ThreadPool.getInstance(); public static final int SYSTEM_BUSY_TASK_COUNT = 150; /* 默认池中线程数 */ public static int worker_num = 5; /* 已经处理的任务数 */ private static int taskCounter = 0; public static boolean systemIsBusy = false; private static List&lt;Task&gt; taskQueue = Collections .synchronizedList(new LinkedList&lt;Task&gt;()); /* 池中的所有线程 */ public PoolWorker[] workers; private ThreadPool() &#123; workers = new PoolWorker[5]; for (int i = 0; i &lt; workers.length; i++) &#123; workers[i] = new PoolWorker(i); &#125; &#125; private ThreadPool(int pool_worker_num) &#123; worker_num = pool_worker_num; workers = new PoolWorker[worker_num]; for (int i = 0; i &lt; workers.length; i++) &#123; workers[i] = new PoolWorker(i); &#125; &#125; public static synchronized ThreadPool getInstance() &#123; if (instance == null) return new ThreadPool(); return instance; &#125; /** * 增加新的任务 * 每增加一个新任务，都要唤醒任务队列 * @param newTask */ public void addTask(Task newTask) &#123; synchronized (taskQueue) &#123; newTask.setTaskId(++taskCounter); newTask.setSubmitTime(new Date()); taskQueue.add(newTask); /* 唤醒队列, 开始执行 */ taskQueue.notifyAll(); &#125; logger.info(\"Submit Task&lt;\" + newTask.getTaskId() + \"&gt;: \" + newTask.info()); &#125; /** * 批量增加新任务 * @param taskes */ public void batchAddTask(Task[] taskes) &#123; if (taskes == null || taskes.length == 0) &#123; return; &#125; synchronized (taskQueue) &#123; for (int i = 0; i &lt; taskes.length; i++) &#123; if (taskes[i] == null) &#123; continue; &#125; taskes[i].setTaskId(++taskCounter); taskes[i].setSubmitTime(new Date()); taskQueue.add(taskes[i]); &#125; /* 唤醒队列, 开始执行 */ taskQueue.notifyAll(); &#125; for (int i = 0; i &lt; taskes.length; i++) &#123; if (taskes[i] == null) &#123; continue; &#125; logger.info(\"Submit Task&lt;\" + taskes[i].getTaskId() + \"&gt;: \" + taskes[i].info()); &#125; &#125; /** * 线程池信息 * @return */ public String getInfo() &#123; StringBuffer sb = new StringBuffer(); sb.append(\"\\nTask Queue Size:\" + taskQueue.size()); for (int i = 0; i &lt; workers.length; i++) &#123; sb.append(\"\\nWorker \" + i + \" is \" + ((workers[i].isWaiting()) ? \"Waiting.\" : \"Running.\")); &#125; return sb.toString(); &#125; /** * 销毁线程池 */ public synchronized void destroy() &#123; for (int i = 0; i &lt; worker_num; i++) &#123; workers[i].stopWorker(); workers[i] = null; &#125; taskQueue.clear(); &#125; /** * 池中工作线程 * * @author obullxl */ private class PoolWorker extends Thread &#123; private int index = -1; /* 该工作线程是否有效 */ private boolean isRunning = true; /* 该工作线程是否可以执行新任务 */ private boolean isWaiting = true; public PoolWorker(int index) &#123; this.index = index; start(); &#125; public void stopWorker() &#123; this.isRunning = false; &#125; public boolean isWaiting() &#123; return this.isWaiting; &#125; /** * 循环执行任务 * 这也许是线程池的关键所在 */ public void run() &#123; while (isRunning) &#123; Task r = null; synchronized (taskQueue) &#123; while (taskQueue.isEmpty()) &#123; try &#123; /* 任务队列为空，则等待有新任务加入从而被唤醒 */ taskQueue.wait(20); &#125; catch (InterruptedException ie) &#123; logger.error(ie); &#125; &#125; /* 取出任务执行 */ r = (Task) taskQueue.remove(0); &#125; if (r != null) &#123; isWaiting = false; try &#123; if (debug) &#123; r.setBeginExceuteTime(new Date()); taskLogger.debug(\"Worker&lt;\" + index + \"&gt; start execute Task&lt;\" + r.getTaskId() + \"&gt;\"); if (r.getBeginExceuteTime().getTime() - r.getSubmitTime().getTime() &gt; 1000) taskLogger.debug(\"longer waiting time. \" + r.info() + \",&lt;\" + index + \"&gt;,time:\" + (r.getFinishTime().getTime() - r .getBeginExceuteTime().getTime())); &#125; /* 该任务是否需要立即执行 */ if (r.needExecuteImmediate()) &#123; new Thread(r).start(); &#125; else &#123; r.run(); &#125; if (debug) &#123; r.setFinishTime(new Date()); taskLogger.debug(\"Worker&lt;\" + index + \"&gt; finish task&lt;\" + r.getTaskId() + \"&gt;\"); if (r.getFinishTime().getTime() - r.getBeginExceuteTime().getTime() &gt; 1000) taskLogger.debug(\"longer execution time. \" + r.info() + \",&lt;\" + index + \"&gt;,time:\" + (r.getFinishTime().getTime() - r .getBeginExceuteTime().getTime())); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(e); &#125; isWaiting = true; r = null; &#125; &#125; &#125; &#125;&#125;/** 任务接口类 **/package org.ymcn.util;import java.util.Date;/*** 所有任务接口* 其他任务必须继承访类* * @author obullxl*/public abstract class Task implements Runnable &#123; // private static Logger logger = Logger.getLogger(Task.class); /* 产生时间 */ private Date generateTime = null; /* 提交执行时间 */ private Date submitTime = null; /* 开始执行时间 */ private Date beginExceuteTime = null; /* 执行完成时间 */ private Date finishTime = null; private long taskId; public Task() &#123; this.generateTime = new Date(); &#125; /** * 任务执行入口 */ public void run() &#123; /** * 相关执行代码 * * beginTransaction(); * * 执行过程中可能产生新的任务 subtask = taskCore(); * * commitTransaction(); * * 增加新产生的任务 ThreadPool.getInstance().batchAddTask(taskCore()); */ &#125; /** * 所有任务的核心 所以特别的业务逻辑执行之处 * * @throws Exception */ public abstract Task[] taskCore() throws Exception; /** * 是否用到数据库 * * @return */ protected abstract boolean useDb(); /** * 是否需要立即执行 * * @return */ protected abstract boolean needExecuteImmediate(); /** * 任务信息 * * @return String */ public abstract String info(); public Date getGenerateTime() &#123; return generateTime; &#125; public Date getBeginExceuteTime() &#123; return beginExceuteTime; &#125; public void setBeginExceuteTime(Date beginExceuteTime) &#123; this.beginExceuteTime = beginExceuteTime; &#125; public Date getFinishTime() &#123; return finishTime; &#125; public void setFinishTime(Date finishTime) &#123; this.finishTime = finishTime; &#125; public Date getSubmitTime() &#123; return submitTime; &#125; public void setSubmitTime(Date submitTime) &#123; this.submitTime = submitTime; &#125; public long getTaskId() &#123; return taskId; &#125; public void setTaskId(long taskId) &#123; this.taskId = taskId; &#125;&#125;","tags":[{"name":"java thread","slug":"java-thread","permalink":"http://yoursite.com/tags/java-thread/"}]},{"title":"eclipseEditorAsisst","date":"2016-09-16T02:30:50.000Z","path":"2016/09/16/eclipseEditorAsisst/","text":"在eclipse中编辑java项目的编辑帮助和一些热键1.增强Eclipse（MyEclipse）输入代码提示功能(1). 打开Eclipse，选择打开” Window －－ Preferences”。 (2). 在目录树上选择”Java－－Editor－－Content Assist”，在右侧的”Auto-Activation”找到”Auto Activation triggers for java”选项。默认触发代码提示的就是”.”这个符号。(3). 在”Auto Activation triggers for java”选项中，在”.”后加上qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM字母。然后”Apply”，点击”OK” 2.一些热键(1)Ctrl+Space 说明:内容助理。提供对方法,变量,参数,javadoc等得提示,应运在多种场合,总之需要提示的时候可先按此快捷键。注:避免输入法的切换设置与此设置冲突 (2)Ctrl+Shift+Space 说明:变量提示 (3)Ctrl+/ 说明:添加/消除//注释,在eclipse2.0中,消除注释为Ctrl+\\ (4)Ctrl+Shift+/ 说明:添加/ /注释 (5)Ctrl+Shift+\\ 说明:消除/ /注释 (6)Ctrl+Shift+F 说明:自动格式化代码 (7)Ctrl+1 说明:批量修改源代码中的变量名,此外还可用在catch块上. (8)Ctril+F6 说明:界面切换 (9)Ctril+Shift+M 说明:查找所需要得包 (10)Ctril+Shift+O 说明:自动引入所需要得包 (11)Ctrl+Alt+S 说明:源代码得快捷菜单。其中的Generate getters and setters 和 Surround with try/catchblock比较常用.建议把它们添加为快捷键.快捷键设置在windows-&gt;preferences-&gt;Workbench-&gt;Keys 2. 快捷键列表编辑作用域 功能 快捷键 行 删除一行 Ctrl+D 全局 查找并替换 Ctrl+F 文本编辑器 查找上一个 Ctrl+Shift+K 文本编辑器 查找下一个 Ctrl+K 全局 撤销 Ctrl+Z 全局 复制 Ctrl+C 全局 恢复上一个选择 Alt+Shift+↓ 全局 剪切 Ctrl+X 全局 快速修正 Ctrl1+1 全局 内容辅助 Alt+/ 全局 全部选中 Ctrl+A 全局 删除 Delete 全局 上下文信息 Alt+？Alt+Shift+?Ctrl+Shift+Space Java编辑器 显示工具提示描述 F2 Java编辑器 选择封装元素 Alt+Shift+↑ Java编辑器 选择上一个元素 Alt+Shift+← Java编辑器 选择下一个元素 Alt+Shift+→ 文本编辑器 增量查找 Ctrl+J 文本编辑器 增量逆向查找 Ctrl+Shift+J 全局 粘贴 Ctrl+V 全局 重做 Ctrl+Y 查看作用域 功能 快捷键 全局 放大 Ctrl+= 全局 缩小 Ctrl+- 窗口作用域 功能 快捷键 全局 激活编辑器 F12 全局 切换编辑器 Ctrl+Shift+W 全局 上一个编辑器 Ctrl+Shift+F6 全局 上一个视图 Ctrl+Shift+F7 全局 上一个透视图 Ctrl+Shift+F8 全局 下一个编辑器 Ctrl+F6 全局 下一个视图 Ctrl+F7 全局 下一个透视图 Ctrl+F8 文本编辑器 显示标尺上下文菜单 Ctrl+W 全局 显示视图菜单 Ctrl+F10 全局 显示系统菜单 Alt+- 导航作用域 功能 快捷键 Java编辑器 打开结构 Ctrl+F3 全局 打开类型 Ctrl+Shift+T 全局 打开类型层次结构 F4 全局 打开声明 F3 全局 打开外部javadoc Shift+F2 全局 打开资源 Ctrl+Shift+R 全局 后退历史记录 Alt+← 全局 前进历史记录 Alt+→ 全局 上一个 Ctrl+, 全局 下一个 Ctrl+. Java编辑器 显示大纲 Ctrl+O 全局 在层次结构中打开类型 Ctrl+Shift+H 全局 转至匹配的括号 Ctrl+Shift+P 全局 转至上一个编辑位置 Ctrl+Q Java编辑器 转至上一个成员 Ctrl+Shift+↑ Java编辑器 转至下一个成员 Ctrl+Shift+↓ 文本编辑器 转至行 Ctrl+L 搜索作用域 功能 快捷键 全局 出现在文件中 Ctrl+Shift+U 全局 打开搜索对话框 Ctrl+H 全局 工作区中的声明 Ctrl+G 全局 工作区中的引用 Ctrl+Shift+G 文本编辑作用域 功能 快捷键 文本编辑器 改写切换 Insert 文本编辑器 上滚行 Ctrl+↑ 文本编辑器 下滚行 Ctrl+↓ 文件作用域 功能 快捷键 全局 保存 Ctrl+X Ctrl+S 全局 打印 Ctrl+P 全局 关闭 Ctrl+F4 全局 全部保存 Ctrl+Shift+S 全局 全部关闭 Ctrl+Shift+F4 全局 属性 Alt+Enter 全局 新建 Ctrl+N 项目作用域 功能 快捷键 全局 全部构建 Ctrl+B 源代码 作用域 功能 快捷键 Java编辑器 格式化 Ctrl+Shift+F Java编辑器 取消注释 Ctrl+\\ Java编辑器 注释 Ctrl+/ Java编辑器 添加导入 Ctrl+Shift+M Java编辑器 组织导入 Ctrl+Shift+O Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。 运行作用域 功能 快捷键 全局 单步返回 F7 全局 单步跳过 F6 全局 单步跳入 F5 全局 单步跳入选择 Ctrl+F5 全局 调试上次启动 F11 全局 继续 F8 全局 使用过滤器单步执行 Shift+F5 全局 添加/去除断点 Ctrl+Shift+B 全局 显示 Ctrl+D 全局 运行上次启动 Ctrl+F11 全局 运行至行 Ctrl+R 全局 执行 Ctrl+U重构作用域 功能 快捷键 全局 撤销重构 Alt+Shift+Z 全局 抽取方法 Alt+Shift+M 全局 抽取局部变量 Alt+Shift+L 全局 内联 Alt+Shift+I 全局 移动 Alt+Shift+V 全局 重命名 Alt+Shift+R 全局 重做 Alt+Shift+Y","tags":[{"name":"eclipseForJava","slug":"eclipseForJava","permalink":"http://yoursite.com/tags/eclipseForJava/"}]},{"title":"operate","date":"2016-09-14T08:49:00.000Z","path":"2016/09/14/operate/","text":"###python字符串中字符大小写的变换： S.lower() 小写 S.upper() 大写 S.swapcase() 大小写互换 S.capitalize() 首字母大写 String.capwords(S)这是模块中的方法。它把S用split()函数分开，然后用capitalize()把首字母变成大写，最后用join()合并到一起 S.title()只有首字母大写，其余为小写，模块中没有这个方法字符串在输出时的对齐： S.ljust(width,[fillchar])输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。 S.rjust(width,[fillchar])右对齐 S.center(width, [fillchar])中间对齐 S.zfill(width)把S变成width长，并在右对齐，不足部分用0补足","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"error","date":"2016-05-21T13:50:36.000Z","path":"2016/05/21/error/","text":"IndentationError: expected an indented block 解决方法：此时只需要在print前面加tab键就可以了，即：后面需要缩进。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"php_install","date":"2016-05-14T09:22:42.000Z","path":"2016/05/14/php-install/","text":"PHPstorm安装问题 1.安装phpStorm 2.打开并运行一个小程序 3.出现了这么一个问题 4.回头看看phpstorm编辑器，发现这个错误 接下来开始解决 首先点击file-&gt;settings-&gt;language &amp; framework-&gt;php 或则如图直接进入 然后点击 找到php解释器路径（我的方案是wamp中的php解释器），如图 点击 apply ok 即可 最后 当你运行时，浏览器中出现 说明已经成功了 tips：建议预先安装wamp集成包","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"install wampServer","date":"2016-05-03T05:00:20.000Z","path":"2016/05/03/install-wampServer/","text":"The solution to the problems when Installed wampServer on win8.1.一.when launched it,a problem show up: *** ERROR *** The PHP configuration loaded file is: - should be: D:/wamp/bin/apache/apache2.4.17/bin/php.ini or d:/wamp/bin/php/php5.6.15/phpforapache.ini here is the solution:请先退出wampServer 1.以管理员身份运行cmd.exe 进入C:\\windows\\system32\\ -&gt; 找到cmd.exe -&gt; 右击并且以管理员身份运行 2.键入命令进入安装apache的目录 我的是 D:\\wamp\\bin\\apache\\apache2.4.17\\bin 3.创建软连接 mklink php.ini d:\\wamp\\bin\\php\\php5.6.15\\phpForApache.ini 成功之后你会看到 为php.ini &lt;&lt; === &gt;&gt; d:\\wamp\\bin\\php\\php5.6.15\\phpForApache.ini 创建的符号链接","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"linux foundation","date":"2016-05-01T15:47:21.000Z","path":"2016/05/01/linux-foundation/","text":"linux特点1.所有内容以文件存储 2.区分大小写 3.不区分拓展名 4.win下程序不能直接在linux上安装和运行 为什么服务器端用linux服务器端要求:安全，稳定 优势一：字符界面占用的系统资源更少 优势二：字符界面减少错误和被攻击的可能性 磁盘分区（把大硬盘分成小的逻辑分区）1.主分区最多只有4个 2.拓展分区：最多只有一个 1.主分区和拓展分区最多有四个 2.不能写入数据，只能包含逻辑分区 3.格式化：写入文件系统 设置， 数据块（block） 【表】节点（node） 4.分区设备文件名：（给每个分区定义设备文件名） 5.挂载：（给每个分区分配挂载点）//分区，目录结合叫挂载 pwd 显示当前目录 tab 目录补全和命令补全 date 显示系统时间 ls -i [文件一] [文件二] 查看文件的inode信息 ctrl+L 清屏 linux命令目录处理命令 0.ls -l 详细信息 可简写为 ll 1.mkdir -p [目录名] -p递归创建，如 Japanese/erpha 一次创建完成 2.cd [目录] cd ~ 进入当前用户的家目录。和直接使用cd一样 cd - 进入上次目录 cd .. 进入上一级目录 cd . 进入当前目录 3.rmdir [空白目录] rm -rf [任意目录] -r删目录-f强制 4.cp 复制 cp -r 复制目录 cp -p 连带文件属性复制 cp -d 若原文件是链接文件，则复制连接属性 cp -a 相当于 -pdr 5.mv [原文见或目录] [目标目录（同目录下为改名，不同目录下为剪切)] 剪切或改名命令 6.ln -s [原文件绝对路径] [目标文件] 连接处理命令(-s 创建软链接，不加的话就是创建硬链接) 软连接类似于win下的快捷方式 有自己的icode 搜索命令 1.locate [文件名]文件搜索命令 在/var/lib/mlocate后台数据库中搜索，该数据库一天更新一次，当然也可以用updatedb强制更新该数据库 2.whereis与which搜索命令的命令-b只看在哪-m只看帮助文档 which查到的是位置和别名 echo $PATH 3.find [搜索范围] -name(/-iname/-user/-nouser/-mtime/-ctime/-atime/-size/-inum)[搜索条件] 按照文件名搜索 完全匹配，可以用通配符模糊查询 4.grep (-v排除指定字符串/-i忽略大小写)[选项] 字符串 文件名 正则表达式包含匹配 帮助命令 1.man 命令 man -f 命令=whatis 命令 （查看命令拥有哪个级别的帮助） man -k 命令=apropos 命令 （查看和命令相关的所有帮助） 2.其他帮助命令 命令 -help选项帮助 help shell内部命令 eg：help cd and help whereis cd info 命令 -回车 进入子帮助页面（带有*好标记） -u 进入上层页面 -n 进入下一个帮助小节 -p 进入上一个帮助小节 -q 退出 压缩与解压缩命令 .zip zip/unzip (-r压缩目录的选项) 压缩文件名 源文件 .gz gzip （-r压缩目录下的所有子文件） 源文件 压缩完源文件将消失 gunzip （-r解压缩目录） 压缩包 .bz2 bzip2 原文件 原文件会消失，想保留原文件加-r选项 不能压缩目录 bunzip2 压缩包 加-k选项的话，压缩包会保留 tar 打包命令（常用） tar -cvf 打包文件名 源文件-c打包-v显示过程-f指定打包后的文件名 tar -xvf 打包文件名 -x解打包-t为查看压缩包内内容 tar -zcvf 压缩包名.tar.gz 原文件 -z压缩为.tar.gz格式 -c换成-x为解压 tar -jcvf 压缩包名.tar.bz2 原文件 压缩包名可以指定路径 tar -jxvf 压缩包名 -C 目录 解压到指定目录 .tar.gz .tar.bz2 关机与重启命令 shutdown [选项] 时间 [&amp;] -c取消前一个关机命令-h关机-r重启&amp;后台启动 下面一般会又损害 关机 halt poweroff init 0 重启 init 6 reboot 退出登录（注销） logout runlevel当前系统运行级别查询init 级别 cat /etc/inittab 修改系统默认运行级别 其他命令 1.挂载命令 mount查看已经挂载的分区 mount -a 依据/etc/fstab/的内容，自动挂载。 1挂载命令格式 mount [-t文件系统] [-o特殊选项] 设备文件名 挂载点 2挂在光盘 mkdir /mut/cdrom/ 创建挂载点（挂在店必须是空目录） mount -t iso9660 /dev/sr0 /mnt/cdrom/ =mount /dev/sr0 /mnt/cdrom/ 简化版 3卸载命令 umount 设备文件名或挂载点 4U盘挂载 fdisk -l 查看系统中已经识别的硬盘 mount -t vfat /dev/sdb1/mnt/usb/ linux默认不支持BTFS文件系统 2.用户登录查看和用户交互命令 w who 简单显示 last 查询当前登录和过去登陆的用户信息 lastlog 查看所有用户的最后一次登录时间 shell基础 shell：命令行解释器 脚本执行方法 echo [选项] [要输出的内容] -e 支持转义字符 echo “zifuchuan ” 输出字符串 echo -e “\\e[1;31m 字符串 \\e[0m” 开启颜色显示颜色值为31m 写脚本 vi 文件名 进入编辑后开始的第一行必须是#!/bin/bash 注释用# 脚本执行 赋予执行权限，直接执行 chmod 755 文件名 ./文件名（相对路径，也可以写绝对路径） 通过bash调用执行脚本 bash 文件名(加路径) bash的基本功能 1.命令别名与快捷键 查看别名 alias 查看系统中已经生效的别名 设定别名 alias 别名=&apos;准确格式的原命令&apos; （注销就不起作用了，永久设置的话，要写入环境变量配置文件 vim ~/.bashrc 也可以直接写入bashrc文件，在source就行了） 删除别名 unalias 命令生效顺序 含路径命令 &gt; 别名 &gt; bash内部命令 &gt; 外部$PATH命令 2.历史命令 history 查看输入过的所有命令 !n 重复执行第n条命令 !!重复执行最后一个命令 !字符串 重复执行以字符串开始的命令 history [选项] [历时命令保存文件] -w强制写入当前命令的历史记录-c清除所有命令 3.输出重定向 指定输出内容的地方 &gt; 覆盖方式 &gt;&gt; 追加的方式 2&gt;&gt;标准错误输出（追加，2&gt;覆盖） *命令 &gt;&gt; 文件 2&gt;&amp;1 如果命令是正确的，则直接写入文件中，错误的，就把报错写入到文件中 *命令 &amp;&gt;&gt;文件名 或则命令 &amp;&gt;文件名 *命令 &gt;&gt; 文件1 2&gt;&gt;文件2 正确信息保存到文件1中错误信息保存到文件2中 输入重定向 wc [选项] [文件名] 最后按下ctrl+d/w/l统计 4.多命令顺序执行 ；顺序执行分号两边的命令 &amp;&amp;两边命令都正确才执行 ||两边命令只要有一个正确的就执行 | 管道符 用法 命令1 | 命令2,命令1的结果作为命令2的操作对象 eg:ls -l /etc | more netstat -an | grep &quot;ESTABLISHED&quot; 查询网络连接中包含ESTA...的行 5.shell中特殊符号 通配符 ? * [] 其他特殊符号 常用快捷键 ctrl + c 强制终止当前命令 ctrl + l 清屏 ctrl + a 光标移动到命令行首 ctrl + e 光标移动到命令行尾 ctrl + u 从光标所在位置删除到行首 ctrl + z 把命令放入后台 ctrl + r 在历时命令中搜索 17/4/17日更新 几张linux命令图 ps： 具体视频请参看imooc中linux达人","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"博客链接","date":"2016-04-22T04:03:36.000Z","path":"2016/04/22/links/","text":"1.Java paradise的博客 2.hexo的详解3.moxfive的博客","tags":[{"name":"links","slug":"links","permalink":"http://yoursite.com/tags/links/"}]},{"title":"初次部署hexo到github上","date":"2016-04-20T09:49:21.000Z","path":"2016/04/20/my-first-post/","text":"部署hexo到github上时遇到了很多问题，搞了两天 一. 错误归结于 deploy： type：github//错误的（有些网上的教程不知道为什么在我这里错了） type：git//正确的（stackflow上查到的） 还要提醒一点repository的设置必须是ssh的协议的url，不是http协议的url 二.我的设置如下 repository: git@github.com:tellen7/tellen7.github.io.git branch: master//部署到master分支上 NOTE 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 三.配置时区错误 timezone: 如果设置不对，将提示这种错误 TypeError: Cannot read property ‘offset’ of null 并且提示 See http://momentjs.com/timezone/docs/#/data-loading/. 所以我没有设置 _ warming 1.配置hexo根目录下的_config.yml文件时要参看官方文档，不要轻易随便改动配置文件 2.如果希望将_config.yml文件中的subtitle:属性值中文内容显示必须将 _config.yml文件编码形式改为 UTF-8 格式。如果用记事本编辑，在 另存为 步骤中修改编码。不过推荐用sublime 打开配置为文件，其支持语法高亮。 3.关于主题配置请参看文档。说明一点，当使用git clone时，应该在 hexo根目录 下打开git bash。应用主题时只要在_config.yml文件中更改 theme:就行了。 4.如果想给自己的文章加标签，那么可以直接在文章中的tags:出添加你想要的标签，不过要切记tags:和标签之间要留一个空格，否者会出现如下错误 YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1: 一定要留空格！！！！这是一个大坑！ 5.其他错误看看这篇博客能不能帮到。 tips 执行hexo New [layout] “new post name”之后会在hexo根目录下的source文件中的_post中生成New post name的markdown文件，用能编辑markdown文件的编辑器打开编辑好保存之后在hexo g(生成静态网页)-&gt;hexo s[可有可无] (localhost:4000中查看效果，不满意再编辑，编辑好之后再 hexo g)-&gt;hexo d(部署到github上) 关于hexo s命令行，可以在markdown编辑文件中直接察看文档效果就行了，完全可以忽略。但是，当你月到错误时，在这个环节查看错无也是必不可少的！ 这里给出了更多主题，知乎上的和github上的。喜欢哪个就用哪个吧。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]