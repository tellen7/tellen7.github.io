[{"title":"线程相关","date":"2018-05-16T00:58:18.000Z","path":"2018/05/16/线程相关/","text":"概念 并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。 同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。 阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。 为什么要用并发编程 多核的CPU的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。 面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。 优缺点优点 资源利用率更好 程序设计在某些情况下更简单 程序响应更快 缺点 CPU线程切换所浪费CPU资源较多 多线程操作设计更复杂和 挑战 避免线程死锁 操作系统里面产生死锁得必要条件有4个： 1. 互斥条件：多线程共享的资源具有互斥特性 2. 不剥夺条件：资源在未使用完毕之前不能被其他进程强行夺走 3. 占有并等待：在等待新资源的同时，继续占有已分配到得资源 4. 环路条件：循环等待之意 只要打破任意一个条件就能避免死锁 创建线程的方法发 通过继承Thread类，重写run方法； 通过实现runable接口； 通过实现callable接口 123456789101112131415161718192021222324252627282930313233343536373839public class CreateThreadDemo &#123; public static void main(String[] args) &#123; //1.继承Thread Thread thread = new Thread() &#123; @Override public void run() &#123; System.out.println(\"继承Thread\"); super.run(); &#125; &#125;; thread.start(); //2.实现runable接口 Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"实现runable接口\"); &#125; &#125;); thread1.start(); //3.实现callable接口 ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = service.submit(new Callable() &#123; @Override public String call() throws Exception &#123; return \"通过实现Callable接口\"; &#125; &#125;); try &#123; String result = future.get(); System.out.println(result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程状态转换可归纳为下表 线程状态的操作 interrupted:中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用isInterrupted（）来感知其他线程对其自身的中断操作，从而做出响应。另外，同样可以调用Thread的静态方法interrupted（）对当前线程进行中断操作，该方法会清除中断标志位。需要注意的是，当抛出InterruptedException时候，会清除中断标志位，也就是说在调用isInterrupted会返回false。一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。 join:可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出，这就像两个好基友，一个基友先走在前面突然看见另一个基友落在后面了，这个时候他就会在原处等一等这个基友，等基友赶上来后，就两人携手并进。 sleep:public static native void sleep(long millis)方法显然是Thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。需要注意的是如果当前线程获得了锁，sleep方法并不会失去锁。 note:sleep() VS wait() sleep()方法是Thread的静态方法，而wait是Object实例方法 wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁； sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。 yield:public static native void yield();这是一个静态方法，一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配给当前线程相同优先级的线程(在创建线程时通过setPriority(int)为创建的县城设置优先级。默认为5【0-10】)。 守护线程运行在后台的线程，比如jvm的垃圾回收线程就是守护线程。线程可以通过setDaemon(true)的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于start()方法 note:守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的 补充同步原理 JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}]},{"title":"牛客网学习笔记","date":"2018-05-05T05:33:43.000Z","path":"2018/05/05/牛客网学习笔记/","text":"jvm内存模型大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register（程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ），其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?jvm参数博客 首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。 servlet一点东西 servlet与cgi servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 servlet生命周期 Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet(2)创建：通过调用servlet构造函数创建一个servlet对象(3)初始化：调用init方法初始化(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求(5)卸载：调用destroy方法让servlet自己释放其占用的资源 note：创建Servlet的实例是由Servlet容器来完成的，且创建Servlet实例是在初始化方法init()之前 线程安全 servlet在多线程下其本身并不是线程安全的。如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。 forward和redirectforward，服务器获取跳转页面内容传给用户，用户地址栏不变redirect，是服务器向用户发送转向的地址，redirect后地址栏变成新的地址 异常详细异常罗列博客 运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 异常是指程序运行时（非编译）所发生的非正常情况或错误，当程序违反了语音规则，jvm就会将出现的错误表示一个异常抛出。异常也是java 的对象，定义了基类 java。lang。throwable作为异常父类。 这些异常类又包括error和exception。两大类error类异常主要是运行时逻辑错误导致，一个正确程序中是不应该出现error的。当出现error一般jvm会终止。exception表示可恢复异常，包括检查异常和运行时异常。 检查异常是最常见异常比如 io异常sql异常，都发生在编译阶段。这类通过try、catch捕捉而运行时异常，编译器没有强制对其进行捕捉和处理。一般都会把异常向上抛出，直到遇到处理代码位置，若没有处理块就会抛到最上层，多线程用thread。run（）抛出，单线程用main（）抛出。常见的运行异常包括 空指针异常 类型转换异常 数组月结异常 数组存储异常 缓冲区溢出异常 算术异常等， jvm参数-Xmx：最大堆大小 -Xms：初始堆大小 -Xmn:年轻代大小 -XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值 Object对象的方法说明1．clone方法保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 2．getClass方法final方法，获得运行时类型。 3．toString方法该方法用得比较多，一般子类都有覆盖。 4．finalize方法该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5．equals方法该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6．hashCode方法该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 7．wait方法wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 8．notify方法该方法唤醒在该对象上等待的某个线程。 9．notifyAll方法该方法唤醒在该对象上等待的所有线程。 线程 run()和start()区别 1.start方法： 用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。 2.run方法： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。 volatile Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。 您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： （1）对变量的写操作不依赖于当前值。 （2）该变量没有包含在具有其他变量的不变式中。 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。","tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"CDN和负载均衡初识","date":"2018-03-24T01:44:20.000Z","path":"2018/03/24/CDN和负载均衡初识/","text":"CDN:CDN也就是内容分布网络(Content Delivery NetWork),它是构筑在现有Internet上的一种先进的流量分配网络，其目的是通过在现有的将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提用户访问网站的响应速度。有别于镜像，它比镜像更智能，可以做这样一一个比喻: CDN=镜像(Mimor)+级存(Cahe)+整体负我均衡(GSLB)。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态页面等数据、用户在从主站服务器请求到动态内容后，再从CDN 上下载这些静态数据，从而加速网页数据内容的下载速度。通常来说CDN要达到以下几个目标。 可扩展(Scalability) 性能可扩展性： 应对新增的大量数据、用户和事务的扩展能力。成本可扩展性用低廉的运营成本提供动态的服务能力和高质量的内容分发。 安全性(Seurity).强调提供物理设备、网络、软件、数据和服务过程的安全性趋势) 減少因为DDOS攻击或者其他恶意行为造成商业网站的业务中断。 可靠性、响应和执行（Reibiliy.Reponivnes 和Perfomance）服务可用性指信够处理可能的故障和用户体验下降的问题，通过负载均衡及时提供网络的容错机制。 CDN架构如图 负载均衡负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或则硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。 三种负载均衡架构： 链路负载均衡:就是通过DNS解析成不同的IP，然后用户根据解析结果访问服务器。用户最终访问哪一台主机是由DNS Server来控制的，即有Global DNS Server来动态解析服务。缺点是:DNS记录解析在用户和Local DNS Server都有缓存，一旦某一台主机挂了，会因DNS解析结果缓存得不到及时更新，而导致用户无法访问域名，从而带来严重后果。 集群负载均衡:分为硬件负载均衡和软件负载均衡，硬件负载均衡需要一台昂贵的硬件设备来转发请求，性能非常好，但是不能及时动态扩容，一般公司也用不起；软件负载均衡成本非常低，用廉价PC就可以搭建，缺点是一般一次访问请求要经过多次代理服务器，会增加网络延时，架构如图: 操作系统负载均衡:利用操作系统级别的中断服务(软中断、硬中断)来达到负载均衡。 除CDN集群中使用负载均衡外，负载均衡更多用于Web服务以及分布式数据集群。","tags":[{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"},{"name":"负载均衡","slug":"负载均衡","permalink":"http://yoursite.com/tags/负载均衡/"}]},{"title":"在springboot中从classpath下加载文件(翻译)","date":"2018-03-23T14:33:33.000Z","path":"2018/03/23/在springboot中从classpath下加载文件/","text":"简介：创建Spring Boot Web应用程序时，有时需要从类路径加载文件，例如，数据仅作为文件提供。就我而言，我使用MAXMIND GeoLite2 database进行位置索引。因此我需要加载文件并创建一个存储在服务器内存中的DatabaseReader对象。 在下面您将找到在WAR和JAR中加载文件的解决方案。The ResourceLoader用java开发时，你可以用当前线程获取classloader，然后用它去加载文件，但是在spring框架中提供了你更优雅得解决方法，如ResourceLoader 你只需要注入对象ResourceLoader之后调用它的getResource(&quot;yourPath&quot;)方法即可。 在Spring Boot（WAR）中从资源目录/ classpath加载文件的示例在以下示例中，我们从类路径中加载一个名为GeoLite2-Country.mmdb的文件作为资源，然后将其作为File对象进行检索。12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Service(\"geolocationservice\")public class GeoLocationServiceImpl implements GeoLocationService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GeoLocationServiceImpl.class); private static DatabaseReader reader = null; private ResourceLoader resourceLoader; @Autowired public GeoLocationServiceImpl(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @PostConstruct public void init() &#123; try &#123; LOGGER.info(\"GeoLocationServiceImpl: Trying to load GeoLite2-Country database...\"); Resource resource = resourceLoader.getResource(\"classpath:GeoLite2-Country.mmdb\"); File dbAsFile = resource.getFile(); // Initialize the reader reader = new DatabaseReader .Builder(dbAsFile) .fileMode(Reader.FileMode.MEMORY) .build(); LOGGER.info(\"GeoLocationServiceImpl: Database was loaded successfully.\"); &#125; catch (IOException | NullPointerException e) &#123; LOGGER.error(\"Database reader cound not be initialized. \", e); &#125; &#125; @PreDestroy public void preDestroy() &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; LOGGER.error(\"Failed to close the reader.\"); &#125; &#125; &#125;&#125; 从Spring Boot JAR中加载文件如果你期望在springboot jar中从classpath中加载文件，你必须要使用resource.getInputStream()方法用输入流去获取文件，如果你试图使用resource.getFile()方法，你将会遇到错误，因为这样的话，spring试图去访问(主机的)文件系统的路径，但是在JAR中是做不到的。123456789101112131415161718192021222324252627282930313233343536373839404142434445@Service(\"geolocationservice\")public class GeoLocationServiceImpl implements GeoLocationService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GeoLocationServiceImpl.class); private static DatabaseReader reader = null; private ResourceLoader resourceLoader; @Inject public GeoLocationServiceImpl(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @PostConstruct public void init() &#123; try &#123; LOGGER.info(\"GeoLocationServiceImpl: Trying to load GeoLite2-Country database...\"); Resource resource = resourceLoader.getResource(\"classpath:GeoLite2-Country.mmdb\"); InputStream dbAsStream = resource.getInputStream(); // &lt;-- this is the difference // Initialize the reader reader = new DatabaseReader .Builder(dbAsStream) .fileMode(Reader.FileMode.MEMORY) .build(); LOGGER.info(\"GeoLocationServiceImpl: Database was loaded successfully.\"); &#125; catch (IOException | NullPointerException e) &#123; LOGGER.error(\"Database reader cound not be initialized. \", e); &#125; &#125; @PreDestroy public void preDestroy() &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; LOGGER.error(\"Failed to close the reader.\"); &#125; &#125; &#125;&#125; 原文链接 下面说一下我在开发文本分类后台服务时遇到的问题问题1说明：用IntelijIEDA开发spring boot web服务时，项目有一个文件需要加载到项目中，因为项目没有构建成jar，在项目中使用ResourceUtils.getFile(&quot;classpath:filepath&quot;)时，项目没有问题，打包成jar部署时，遇到了 java.io.FileNotFoundException: class path resource [static/Sample.txt] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/C:/workspace-test/XXX/target/XXX-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/static/Sample.txt 这样的错误，百度查了一大堆没有实质性帮助的结果，后来去StackOverflow上查到了，这样回答的 I have checked your code.If you would like to load a file from classpath in a Spring Boot JAR, then you have to use the resource.getInputStream() rather than resource.getFile().If you try to use resource.getFile() you will receive an error, because Spring tries to access a file system path, but it can not access a path in your JAR 解决方法:因为项目中用了第三方jar包(这里还有一个开发问题),接口需要文件路径字符串，jar中又不能getFile().getURL(),所以不能获取相对路径，网上有一个把文件读入inputStream中，然后再写到项目的路径下，保存问临时文件，在获取路径。尝试了，还是不行。最后是在jar中读取部署服务的主机上真实存在的资源文件，使用绝对路径（其实我是把jar中文件拷贝到主机的目录下，然后再写上绝对路径）。 代码实例 问题2说明：使用了第三方jar，用maven构建项目打包时，会找不到第三方jar资源，因此会报ClassNotFound错误 棘角方法解决方法有很多，我才用把第三方jar发布到本地maven仓库中，但是这样做项目的协同开发不太友好，其他开发者电脑上的本地maven仓库也需要进行相同的jar发布才可以。考虑到我是一个人开发，就没有但有这么多。 注翻译它是因为最近写一个web服务时遇到了点问题，这篇文章起了一点作用","tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"springBoot跨域访问模拟","date":"2018-03-17T12:39:14.000Z","path":"2018/03/17/springBoot跨域访问模拟/","text":"微服务架构现在很流行，把一个项目拆分成很多服务进行单独开发，这对开发来说不仅能提高开发效率，还能是的项目逻辑上更清晰，后期维护更容易等等好处。 跨域访问场景 ：现在尝试开发一个后台，前端服务器里面有个页面使用ajax异步请求我后台服务器上的服务（开放API），现在有一个浏览器请求了前端页面，浏览器因为同源策略（限制javascript的安全机制）会屏蔽掉ajax请求的结果，可以在控制台上看到No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://localhost:8080&#39; is therefore not allowed access.。请求结果被浏览器限制了。所谓跨域就是不同域名主机的互相访问。 解决方法： 通过JSONP动态插入另一台主机上的script代码，其原理就是前端代码中&lt;script src=&quot;...&quot;&gt;返回的是可以被javascript执行的脚本。 用前端服务器的XmlHttpRequest代理来跨域访问资源，而不是在浏览器端让浏览器执行请求不同域的资源。 我后端的做法就是在响应的实体中加入控制信息，即添加Filter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AuthFilter implements Filter &#123; // @Autowired //这个不能自动注入servlet和filter是被tomcat管理的 private String[] excludePaths; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"initFilter\"); //不能在初始化中通过Appliaction Context获取因为这时候还没初始化Application Context //baseUserService = SpringUtils.getBean(\"baseUserService\", BaseUserService.class); excludePaths = new String[]&#123;\"/api/user/noLogin\", \"/api/user/tokenError\", \"/api/user/loginForeground\", \"/api/user/loginBackground\", \"/api/user/inCorrectUserId\"&#125;; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; //这里填写你允许进行跨域的主机ip httpServletResponse.setHeader(\"Access-Control-Allow-Origin\", \"*\"); //允许的访问方法 httpServletResponse.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PUT, OPTIONS, DELETE, PATCH\"); //Access-Control-Max-Age 用于 CORS 相关配置的缓存 httpServletResponse.setHeader(\"Access-Control-Max-Age\", \"3600\"); httpServletResponse.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"); String path = httpServletRequest.getServletPath(); if (excludePath(path)) &#123; chain.doFilter(request, response); &#125; else &#123; httpServletRequest.getRequestDispatcher(\"/api/user/noLogin\").forward(request, response); &#125; &#125; private boolean excludePath(String path) &#123; for (int i = 0; i &lt; excludePaths.length; i++) &#123; if (path.equals(excludePaths[i])) return true; &#125; return false; &#125; @Override public void destroy() &#123; System.out.println(\"destroy method\"); &#125;&#125; 或则编写一个配置类，配置跨域访问问题12345678910111213@Configuration public class CorsConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true) .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\") .maxAge(3600); &#125; &#125; 基于springboot构建的服务，最简单的就是在控制器上加一个注解@CrossOrigin//允许跨域请求1234567891011@Controller@CrossOrigin//允许跨域请求@RequestMapping(\"/api\")public class MLpicture &#123; @RequestMapping(value = \"/getResult\",method = RequestMethod.POST) public @ResponseBody String getResult( @Valid Person person)&#123; System.out.println(person.toString()); return \"result\"+person.toString()+\"\\n\"; &#125;&#125; 测试实况：前端主机：localhost:8080/temp页面后端服务主机：localhost:8000/api/getResult1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login test&lt;/title&gt; &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function login() &#123; $.ajax(&#123; //几个参数需要注意一下 type: \"POST\",//方法类型 dataType: \"json\",//预期服务器返回的数据类型 url: \"http://localhost:8000/api/getResult\" ,//url data: $('#form1').serialize(), success: function (result) &#123; console.log(result);//打印服务端返回的数据(调试用) if (result.resultCode == 200) &#123; alert(\"SUCCESS\"); &#125; ; &#125;, error : function() &#123; alert(\"wrong\"); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"form-div\"&gt; &lt;form id=\"form1\" onsubmit=\"return false\" action=\"##\" method=\"post\"&gt; education&lt;input type=\"text\" name=\"education\"&gt;&lt;br&gt; major&lt;input type=\"text\" name=\"major\"&gt;&lt;br&gt; school&lt;input type=\"text\" name=\"school\"&gt;&lt;br&gt; jobLocation&lt;input type=\"text\" name=\"jobLocation\"&gt;&lt;br&gt; workingYears&lt;input type=\"text\" name=\"workingYears\"&gt;&lt;br&gt; skills&lt;input type=\"text\" name=\"skills\"&gt;&lt;br&gt; position&lt;input type=\"text\" name=\"position\"&gt;&lt;br&gt; selfIntroduction&lt;input type=\"text\" name=\"selfIntroduction\"&gt;&lt;br&gt; &lt;p&gt;&lt;input type=\"button\" value=\"submit\" onclick=\"login()\"&gt;&amp;nbsp;&lt;input type=\"reset\" value=\"reset\"&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后台没有在控制器上加@CrossOrigin注解，返回的是后台在控制器上加@CrossOrigin注解，返回的是 ** 注： spring boot 的官方samples地址 本文代码部分引用这个博客","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"跨域访问","slug":"跨域访问","permalink":"http://yoursite.com/tags/跨域访问/"}]},{"title":"spring boot 返回json数据","date":"2018-03-12T04:02:55.000Z","path":"2018/03/12/spring-boot-返回json数据/","text":"* description of the questionNo converter found for return value of type: class java.util.LinkedHashMap * solution to the question1.检查是否配置json解析器123456789101112131415161718192021222324@Configurationpublic class CustomMVCConfiguration extends WebMvcConfigurationSupport&#123; @Bean public HttpMessageConverter&lt;String&gt; responseBodyConverter() &#123; StringHttpMessageConverter converter = new StringHttpMessageConverter( Charset.forName(\"UTF-8\")); return converter; &#125; @Override public void configureMessageConverters( List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super.configureMessageConverters(converters); //添加json转换器（需要现在maven里添加jacson包依赖） converters.add(new MappingJackson2HttpMessageConverter()); converters.add(responseBodyConverter()); &#125; @Override public void configureContentNegotiation( ContentNegotiationConfigurer configurer) &#123; configurer.favorPathExtension(false); &#125;&#125; 2.maven中是否引入jacson包依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; 3.controller对应方法上是否有@ResponseBody注解 1234@GetMapping(path = \"/getAll\") public @ResponseBody Iterable&lt;User&gt; getAll() &#123; return userRepository.findAll();//返回的是LinkedHashMap，@ResponseBody会提示框架自动调用json解析器 &#125;","tags":[{"name":"springBoot","slug":"springBoot","permalink":"http://yoursite.com/tags/springBoot/"}]},{"title":"利用神经网络进行数据降维","date":"2017-11-08T06:38:48.000Z","path":"2017/11/08/利用神经网络进行数据降维/","text":"利用神经网络进行数据降维降维为什么要降维？ 去除存在噪音数据，减少模型干扰因素 减少计算量 便于可视化分析 常见降维方法 主成分分析法（PCA） 线性判别分析法（LCA） 神经网络 神经网络感知器受到人类大脑神经网络启发： 多层神经网络决策模型： 确定权重和阀值输入线性处理（Sigmoid）σ(z) = 1 / (1 + e^(-z)) BP神经网络模型BP算法全称叫作误差反向传播算法。其算法基本思想为：输入信号经输入层输入，通过隐层计算由输出层输出，输出值与标记值比较，若有误差，将误差反向由输出层向输入层传播，在这个过程中，利用梯度下降算法对神经元权值进行调整。 存在的问题： 局部极小值问题：随机给神经元赋一个权值，当这个权值太大的话，就很容易收敛到”差”的局部收敛点，权值太小的话则在进行误差反向传递时离输入层越近的权值更新越慢 RBM(限制波尔兹曼机)两层神经元之间都是全连接的，但是每一层各自的神经元之间并没有连接，也就是说，RBM的图结构是一种二分图（bipartite graph） 对模型进行预训练，快速找到全局最优点，计算权值矩阵和偏移量，以加快后续的BP训练。 能量函数 使系统达到稳定状态：能量函数值最小 降维步骤Pretaining 预处理包含了 学习 一个 受限玻尔兹曼机栈（ 堆叠的RBM），每一个只有一层特征监测子。一层RBM学习过的数据作为下一层RBM的输入，然后使用BP算法调整参数。 Unrolling根据encode的结果，和一系列的WT做矩阵乘法，最后得到vrecon的过程 Fine-tuningstochastic gradient decent过程，目标函数： cost=−∑ivi⋅log(Virecon)+(1−vi)⋅log(1−virecon) 图示 和pca对比相比于pca分解出来的特征，auto encoder获得的特征有更好的区分度可以通过把784维特征降成2维，然后画出这些特征的分布的。 如图 可以看到，RandomizedPCA降成2维后，好像只有0、1、2这3个数能较好的区分出来。而4层级联encoder网络（每层节点数分别为1000、500、250、2）得到的结果基本可以把所有数字的大部分都分解出来。不过，4、7、8、9重叠较多，5好像跟8也有较多重叠，这些从测试集合上也可以理解。 pca从2维重构回的“原始图片” 神经网络重构出的“原始图片” 神经网络重构出的“原始图片”明显优于pca从2维重构回的“原始图片”","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"}]},{"title":"Spring MVC拦截器学习","date":"2017-05-21T11:02:11.000Z","path":"2017/05/21/MVC拦截器学习/","text":"学习spring mvc拦截器浅析1.简介 spring mvc中的拦截器和原声java web中的filter差不多，起到过滤、拦截的作用。使用原则：处理共性问题；其主要做用有： 日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。 权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面； 性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）； 通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。 OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。 (请求数据编码) 本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。 2.实现方法 编写拦截器，实现HandlerIntercepter接口,实现抽象方法。 将拦截器注册到spring MVC框架中接口源码123456789101112131415161718192021222324package org.springframework.web.servlet; public interface HandlerInterceptor &#123; //预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器 //返回值：true表示继续流程（如调用下一个拦截器或处理器） //false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应； boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; //后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; //整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。 void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; &#125; 盗图一张 源码级流程解析，引用自开涛,来看一下DispatcherServlet内部到底是如何工作的吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 //doDispatch方法 //1、处理器拦截器的预处理（正序执行） HandlerInterceptor[] interceptors = mappedHandler.getInterceptors(); if (interceptors != null) &#123; for (int i = 0; i &lt; interceptors.length; i++) &#123; HandlerInterceptor interceptor = interceptors[i]; if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) &#123; //1.1、失败时触发afterCompletion的调用 triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null); return; &#125; interceptorIndex = i;//1.2、记录当前预处理成功的索引 &#125; &#125; //2、处理器适配器调用我们的处理器 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); //当我们返回null或没有返回逻辑视图名时的默认视图名翻译（详解4.15.5 RequestToViewNameTranslator） if (mv != null &amp;&amp; !mv.hasView()) &#123; mv.setViewName(getDefaultViewName(request)); &#125; //3、处理器拦截器的后处理（逆序） if (interceptors != null) &#123; for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv); &#125; &#125; //4、视图的渲染 if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, processedRequest, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; //5、触发整个请求处理完毕回调方法afterCompletion triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null); ``` 注：代码片段 ```java // triggerAfterCompletion方法 private void triggerAfterCompletion(HandlerExecutionChain mappedHandler, int interceptorIndex, HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception &#123; // 5、触发整个请求处理完毕回调方法afterCompletion （逆序从1.2中的预处理成功的索引处的拦截器执行） if (mappedHandler != null) &#123; HandlerInterceptor[] interceptors = mappedHandler.getInterceptors(); if (interceptors != null) &#123; for (int i = interceptorIndex; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; try &#123; interceptor.afterCompletion(request, response, mappedHandler.getHandler(), ex); &#125; catch (Throwable ex2) &#123; logger.error(\"HandlerInterceptor.afterCompletion threw exception\", ex2); &#125; &#125; &#125; &#125; &#125; 正式实现：1.实现HandlerIntercepter接口并且实现抽象方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.laowang.mainInterceter;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;/** * Created by tellenw on 17-5-21. * 这是一个spring 拦截器 * 1. 编写拦截器，实现HandlerIntercepter接口,实现抽象方法。 * 2. 将拦截器注册到spring MVC框架中 * 3. */public class FirstIntercepter implements HandlerInterceptor &#123; /** * * @param httpServletRequest * @param httpServletResponse * @param o :表示被拦截的请求的目标对象 * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println(\"this is in preHandle...\"); return true;//返回值表示是否将当前请求拦截下来，true：请求继续;false：请求将被拦截，请求不会到达控制器。 &#125; /** * * @param httpServletRequest * @param httpServletResponse * @param o * @param modelAndView :可以通过modelAndView参数修改显示的视图，或者修改发往视图的方法 * @throws Exception */ @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"this is in postHandle...\"); //下面将通过modelAndView参数对返回数据进行修改 Map&lt;String,Object&gt; model = modelAndView.getModel(); if(model.containsKey(\"msg\"))&#123; String msg = (String) model.get(\"msg\"); modelAndView.addObject(\"msg\",msg+\"-&gt;这条消息被拦截到了！\"); &#125; //也可以通过modelAndView对返回的视图名修改 //modelAndView.setViewName(); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println(\"this is in afterCompletion...\"); &#125;&#125; 2.在springmvc容器中注册拦截器1234567891011&lt;!--用与拦截所有请求--&gt; &lt;!--&lt;mvc:interceptors&gt;--&gt; &lt;!--&lt;bean class=\"com.laowang.mainInterceter.FirstIntercepter\"/&gt;--&gt; &lt;!--&lt;/mvc:interceptors&gt;--&gt; &lt;!--拦截指定请求,/check.form的请求--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/check.form\"/&gt; &lt;bean class=\"com.laowang.mainInterceter.FirstIntercepter\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 下面展示相关代码响应的处理器12345678910111213141516171819@RequestMapping(value = \"check.form\", method = RequestMethod.POST)public ModelAndView checkForm(String name,String password)&#123; ModelAndView modelAndView = new ModelAndView(); System.out.println(\"in check form method ...\"); System.out.println(\"name: \"+name); System.out.println(\"password: \"+password); //if(\"tellenw\".equals(name) &amp;&amp; \"admin123\".equals(password))&#123; if(\"admin\".equals(password))&#123; modelAndView.setViewName(\"index\"); modelAndView.addObject(\"msg\",name); &#125;else&#123; modelAndView.setViewName(\"login\"); modelAndView.addObject(\"msg\",\"登录信息有误！请重新登录！\"); &#125; return modelAndView;&#125; 相关的视图成功&lt;h1 align=&quot;center&quot;&gt;welcome ${msg}&lt;/h1&gt;不成功&lt;h3 style=&quot;color: crimson&quot;&gt;${msg}&lt;/h3&gt; 补充：还可以通过实现WebRequestInterceptor接口实现连接功能，但是没有HandlerIntercepter的功能全。方法名相同参数有点不同。其preHandle方法没有返回值，不能中止请求。 最后把很好的教程收藏","tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://yoursite.com/tags/spring-mvc/"}]},{"title":"正确使用谷歌","date":"2017-05-20T16:27:17.000Z","path":"2017/05/21/正确使用谷歌/","text":"搜索中的hack我们平时使用搜索引擎，最简单直接的就是输入想要查找的内容，然后点击搜索。但是这种搜索效率不高！不能准确定位要查找的内容。下面将介绍搜索中的hack方法。intext:这个就是把网页中的正文内容中的某个字符做为搜索条件.例如在google里输入:intext:动网.将返回所有在网页正文部分包含”动网”的网页. allintext:使用方法和intext类似. intitle:和上面那个intext差不多,搜索网页标题中是否有我们所要找的字符.例如搜索:intitle:安全天使.将返回所有网页标题中包含”安全天使”的网页.同理 allintitle:也同intitle类似. cache:搜索google里关于某些内容的缓存,有时候也许能找到一些好东西哦. define:搜索某个词语的定义,搜索:define:hacker,将返回关于hacker的定义. filetype:这个我要重点推荐一下,无论是撒网式攻击还是我们后面要说的对特定目标进行信息收集都需要用到这个.搜索指定类型的文件.例如输入:filetype:doc.将返回所有以doc结尾的文件URL.当然如果你找.bak、.mdb或.inc也是可以的,获得的信息也许会更丰富inf查找指定站点的一些基本信息. inurl:搜索我们指定的字符是否存在于URL中.例如输入:inurl:admin,将返回N个类似于这样的连接http://www.claepo.com/xxx/admin,用来找管理员登陆的URL不错. allinurl也同inurl类似,可指定多个字符. link:例如搜索:inurl:www.4ngel.net可以返回所有和www.claepo.com做了链接的URL. site:这个也很有用,例如:site:claepo.com 将返回所有和claepo.com这个站有关的URL. 下面是附加 找管理后台地址：site:xxx.com intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号site:xxx.com inurl:login/admin/manage/manager/admin_login/login_admin/system/boss/mastersite:xxx.com intitle:管理|后台|登陆| 找上传一类的漏洞：site:xxx.com inurl:filesite:xxx.com inurl:load 找注入点页面：site:xxx.com inurl:php?id= 找编辑器页面：site:xxxx.com inurl:fcksite:xxx.com inurl:ewebeditor 找重要文件：site:xxx.com inurl:robots.txtsite:xxx.com filetype:mdbsite:xxx.com filetype:inisite:xxx.com inurl:txt site:xxx.com filetype:phpsite:xxx.com filetype:asp 注意：不要带上www，因为这样可以搜索到二级域名哦！搜索的文件名只是抛砖引玉，想出更多的文件名来发挥到极致！ 最后PS可以在搜索引擎的搜索栏中右击修改搜索引擎。","tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"hadoop入门","date":"2017-05-13T10:16:16.000Z","path":"2017/05/13/hadoop入门/","text":"准备工作 linux环境 安装并配置好jdk(java) 安装并配置好hadoop linux环境可以使用虚拟机，也可以租用云主机 安装jdk 先javac会提示没有安装，同时还会提示怎么安装 按照提示安装open jdk …apt-get install ... 根据安装提示，找到安装路径，配置java环境变量 /usr/lib/jvm/java-7-openjdk-amd64/...复制备用vi /etc/profile添加配置信息 1234export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$JAVAHOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin:$PATH source /etc/profile使配置的环境变量生效 输入javac测试是否生效warn：如果是桌面版Ubuntu 16.04 LTS的话，不能按照上述方法。配置java环境变量的文件在~/.bashrc文件下，如果更改/etc/profile文件，将会覆盖掉很大一部分linux命令，sudo都不能用，生效配置用source 安装并配置好hadoop 下载hadoop http://www.apache.org/dyn/closer.cgi/hadoop/common/ 选好镜像版本复制下载链接，在terminal中用wget http://...（下载地址） （可选）移动hadoop到/opt目录下，并解压tar -xzvf ... 三种运行方式1.单机模式默认情况下，Hadoop 被配置成以非分布式模式运行的一个独立 Java 进程。这对调试非常有帮助。 下面的实例将已解压的 conf 目录拷贝作为输入，查找并显示匹配给定正则表达式的条目。输出写入到指定的 output 目录。 cp LICENSE.txt input #把license.txt复制到input文件夹&gt;当中cd .. ＃回到上一级目录hadoop jar hadoop-examples-1.2.1.jar wordcount input &gt;output #运行wordcount例子，结果放到output文件夹当中cat output/* #结果呈现 2.伪分布式Hadoop安装 vi hadoop-env.sh配置JAVA_HOME(echo $JAVA_HOME) 到conf目录下vi core-site.xml添加下面配置信息 12345678910111213141516&lt;configuration&gt;&lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/hadoop&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/hadoop/name&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 配置vi hdfs-site.xml 12345&lt;configuration&gt;&lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/hadoop/data&lt;/value&gt;&lt;/property&gt; 配置vi fair-scheduler.xml 123456&lt;allocations&gt;&lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;localhost:9001&lt;/value&gt;&lt;/property&gt;&lt;/allocations&gt; 配置hadoop环境变量，类似java环境变量的配置vi /etc/profile添加export HADOOP_HOME=/opt/hadoop-1.2.1 生效配置source /etc/profile 测试hadoop是否配置成功，直接输入hadoop，会出现使用脚本信息 最后格式化。。。hadoop namenode -format 准备工作完结,以后再添加说明cd到bin目录，启动start-all.sh用jps查看hadoop是否正常运行hadoop fs -ls /查看hadoop下有哪些文件 未完。。。。 （补充：1. 打开ssh服务，/etc/init.d/ssh start开启ssh-server2.这边不错）","tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"}]},{"title":"spring MVC两个应用上下文的故事","date":"2017-04-30T05:12:06.000Z","path":"2017/04/30/spring-MVC两个应用上下文的故事/","text":"最靓仔学习spring mvc时，对web.xml文件中配置的应用上下文感到困惑。于是上网找了资料。 《spring Action》书中说到： 当DispatcherServlet启动时，会创建Spring应用上下文，并加载配置文件或配置类中所声明的bean。但是在Spring Web应用中还有另外一个应用上下文，由ContextLoaderListener创建的。 我们希望DispatcherServlet加载包含web组件的bean，如控制器，视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean，通常是应用后端的中间件和数据层组件。 当web容器tomcat启动时，会作如下事情： 启动一个WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点: &lt;listener&gt;&lt;/listener&gt; 和 &lt;context-param&gt;&lt;/context-param&gt; 紧接着,容器创建一个ServletContext(上下文)。在该应用内全局共享。 容器将&lt;context-param&gt;&lt;/context-param&gt;转化为键值对,并交给ServletContext. 容器创建&lt;listener&gt;&lt;/listener&gt;中的类实例,即创建监听.该监听器必须实现自ServletContextListener接口 在监听中会有contextInitialized(ServletContextEvent event)初始化方法，在这个方法中获得ServletContext = ServletContextEvent.getServletContext();“context-param的值” = ServletContext.getInitParameter(‘context-param的键’); 得到这个context-param的值之后,你就可以做一些操作了.注意,这个时候你的WEB项目还没有完全启动完成.这个动作会比所有的Servlet都要早.换句话说,这个时候,你对中的键值做的操作,将在你的WEB项目完全启动之前被执行. web.xml中可以定义两种参数：一个是全局参数(ServletContext)，通过 &lt;context-param&gt;&lt;/context-param&gt; 另一个是servlet参数，通过在servlet中声明 &lt;init-param&gt; &lt;param-name&gt;param1&lt;/param-name&gt; &lt;param-value&gt;avalible in servlet init()&lt;/param- value&gt; &lt;/init-param&gt; note：第一种参数在servlet里面可以通过getServletContext().getInitParameter(‘context/param’)得到；第二种参数只能在servlet的init()方法中通过this.getInitParameter(‘param1’)取得。 spring上下文的初始化 servlet容器启动，为应用创建一个“全局上下文环境”：ServletContext 容器调用web.xml中配置的contextLoaderListener，初始化WebApplicationContext上下文环境（即IOC容器），加载context-param指定的配置文件信息到IOC容器中。WebApplicationContext在ServletContext中以键值对的形式保存 容器初始化web.xml中配置的servlet，为其初始化自己的上下文信息servletContext，并加载其设置的配置信息到该上下文中。将WebApplicationContext设置为它的父容器。 此后的所有servlet的初始化都按照3步中方式创建，初始化自己的上下文环境，将WebApplicationContext设置为自己的父上下文环境。 图示其间关系 参考地址1，2","tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://yoursite.com/tags/spring-mvc/"}]},{"title":"Ubuntu安装docker","date":"2017-04-27T10:51:57.000Z","path":"2017/04/27/Ubuntu安装docker/","text":"简要步骤step 1 wget -qO- https://get.docker.com/ | sh 结果如下 note 我个人在ubuntu虚拟机中实验，32位的安装docker时，执行该命令有问题。什么i836的。64为的没有问题。 在结果图中，更改docker运行用户的问题，不改的话，如果执行docker run hello-world时会有问题 docker: Cannot connect to the Docker daemon. Is … 报了docker守护线程没有开启，用ps -ef看了下是开启的。其实是用sudo docker run命令才对，不过还是有点问题。 step 21sudo usermod -aG docker (yourUsername) step 312wyh@ubuntu:~$ sudo service docker startwyh@ubuntu:~$ sudo docker run hello-world 运行结果： 最后附上关闭docker服务的命令sudo service docker stop ================================================更新，下面是一些实践 安装ubuntu镜像（images） sudo docker run ubuntu 说明：初次运行会检查本地是否有ubuntu镜像的虚拟机，如果没有将会从镜像库docker hub上下载公共镜像。sudo docker run ubuntu echo &quot;hello world&quot;该命令会在ubuntu虚拟机中执行echo命令并输出hello world。note运行交互式容器sudo docker run -it ubuntu -t:在新容器内指定一个伪终端或终端。 -i:允许你对容器内的标准输入 (STDIN) 进行交互。进入交互式容器，说明你已经在容器内了，可以像使用ubuntu一样使用命令行。退出交互式容器ctrl+D 启动容器（后台模式） 使用以下命令创建一个以进程方式运行的容器 sudo docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; 在输出中，我们没有看到期望的”hello world”，而是一串长字符 cf69880d847fb97e6eb8b5b2e513a9123a0b3e3d3fbdd4503b8ab14df1236923 这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。 首先，我们需要确认容器有在运行，可以通过 sudo docker ps 来查看。结果如下： wyh@ubuntu:~$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cf69880d847f ubuntu &quot;/bin/sh -c &apos;while...&quot; 7 seconds ago Up 7 seconds tender_stonebraker 查看容器内的标准输出wyh@ubuntu:~$ sudo docker logs cf69880d847fb97e6e 停止容器sudo docker stop cf69880d847f 为了验证容器是否停止，查看容器镜像运行进程sudo docker ps 查看docker的命令sudo docker 查看某个命令的帮助docker command --help 运行一个web应用尝试使用 docker 构建一个 web 应用程序。 在docker容器中运行一个 Python Flask 应用来运行一个web应用。 sudo docker run -d -P training/webapp python app.py 参数说明: -d:让容器在后台运行。 -P:将容器内部使用的网络端口映射到我们使用的主机上。 运行sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d1cb9c07119 training/webapp &quot;python app.py&quot; About a minute ago Up About a minute 0.0.0.0:32768-&gt;5000/tcp confident_rosalind 接下来再本机浏览器中输入http://127.0.0.1:32768/即可查看到内容，127.0.0.1也可以换成docker的ip，试过了，一样！ 指定端口sudo docker run -d -p 5000:5000 training/webapp python app.py 1234567891011121314151617181920212223242526272829303132333435wyh@ubuntu:~$ sudo docker port flamboyant_neumann 查看某容器的端口5000/tcp -&gt; 0.0.0.0:5000wyh@ubuntu:~$ sudo docker logs -f 202 查看容器内部的标准输出（-f:让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出。） * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)172.17.0.1 - - [27/Apr/2017 12:24:16] \"GET / HTTP/1.1\" 200 -172.17.0.1 - - [27/Apr/2017 12:24:16] \"GET /favicon.ico HTTP/1.1\" 404 -172.17.0.1 - - [27/Apr/2017 12:24:16] \"GET /favicon.ico HTTP/1.1\" 404 -^Z[7]+ 已停止 sudo docker logs -f 202wyh@ubuntu:~$ sudo docker top 202 查看容器内进程UID PID PPID C STIME TTY TIME CMDroot 15167 15149 0 20:22 ? 00:00:00 python app.pywyh@ubuntu:~$ sudo docker inspect 202 它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。runoob@runoob:~$ docker inspect determined_swanson[ &#123; \"Id\": \"7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361\", \"Created\": \"2016-05-09T16:20:45.427996598Z\", \"Path\": \"python\", \"Args\": [ \"app.py\" ], ...wyh@ubuntu:~$ sudo docker ps -l 查看最后一次启动的容器CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES202def58eb83 training/webapp \"python app.py\" 10 minutes ago Exited (137) 22 seconds ago flamboyant_neumannwyh@ubuntu:~$ sudo docker restart 202 重启（最后一次启动的）容器wyh@ubuntu:~$ sudo docker stop 202202 停止容器wyh@ubuntu:~$ sudo docker rm 202202 移除容器wyh@ubuntu:~$ sudo docker restart 202 查看是否成功移除Error response from daemon: No such container: 202 =============================5月7号晚上更新 自定义docker镜像 创建Dockerfile文件 编写如下内容 from hub.c.163.com/library/tomcat #拓展自哪个镜像 MAINTAINER laowang 643710049@qq.com #用户名。邮箱 COPY jpress.war /usr/local/tomcat/webapps/ #copy本地文件到镜像目标文件夹 docker build -t jpress:latest .提示如下 1234567891011 Sending build context to Docker daemon 20.8MBStep 1/3 : FROM hub.c.163.com/library/tomcat ---&gt; 1f6eab5f63d3Step 2/3 : MAINTAINER laowang 643710049@qq.com ---&gt; Running in becafadad4b1 ---&gt; 6639dfe8255fRemoving intermediate container becafadad4b1Step 3/3 : COPY jpress.war /usr/local/tomcat/webapps/ ---&gt; af1cb028eaa0Removing intermediate container 88c6cbcb6a6bSuccessfully built af1cb028eaa0 成功了 docker命令大全外链","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Ubuntu16.04 install LAMP","date":"2017-04-25T13:47:56.000Z","path":"2017/04/25/Ubuntu16-04-install-LAMP/","text":"linux下开发必备环境 安装apache2 1sudo apt-get install apache2 安装结果 /etc/apache2/ |-- apache2.conf | `-- ports.conf |-- mods-enabled | |-- *.load | `-- *.conf |-- conf-enabled | `-- *.conf |-- sites-enabled | `-- *.conf 项目文件在/var/www/ 启动apache2服务 service apache2 start 打开浏览器，打开http://127.0.0.1/进行验证 安装php7 12345678sudo apt-get install php7.0 sudo apt-get install libapache2-mod-php7.0 // 配置APACHE+PHP7的sudo apt-get install libapache2-mod-php // 这个应该是配置APACHE+PHP5的，一块装吧sudo /etc/init.d/apache2 restart // 重启 在项目目录里创建测试文件test.php内容如下： hello php &lt;?php phpinfo(); ?&gt; 浏览器打开http://127.0.0.1/test.php进行验证 -安装mysql1apt-get install mysql-server mysql-client notemysql-server：用来创建和管理数据库实例，提供相关接口供不同客户端调用;mysql-client：操作数据库实例的的一个命令行工具，像图形化界面工具有phpmyadmin等;mysqld：即MySQL servermysql：即mysql-client客户端命令行工具 启动服务service mysql start 验证是否开启mysql服务 ps -ef | grep mysql ps：自启动管理工具 apt-get install sysv-rc-conf","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"使用git的基本式jgit的基本（优雅）方式“","date":"2017-04-21T15:17:55.000Z","path":"2017/04/21/使用git的基本式jgit的基本（优雅）方式“/","text":"从开始使用git到养成习惯，就是这么简单先上图表示一下基本流程 首先下载git for windows,直接安装。 添加SSH KEY，在github上“setting”里面按照步骤进行。 在github上创建一个仓库，例如test。 在本地的项目（test项目）文件夹下右键Git bash here。 输入 git init，这个命令会在项目目录下生成一个.git的目录，这里面存放的就是项目的版本库和git配置文件。 为了利用github给你智能生成的.gitignore和readme.md文件，先将github上的仓库pull一下，在git bash终端输入git pull https://github.com/~~~/test.git 添加项目更新，git add . 提交项目更新，git commit -m “first time commit” 建立远程仓库，git remote add origin https://github.com/~~~/test.git push更新，git push -u origin master 这样本地仓库就与github上面仓库建立联系啦，以后就可以愉快的玩耍了。 PS：下面附赠git常用命令行","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"spring基于@Value绑定属Bean性失","date":"2017-04-20T09:34:52.000Z","path":"2017/04/20/spring基于-Value绑定属Bean性失/","text":"用spring注解@Value绑定属性失败环境： eclipse Version: Luna Release (4.4.0) spring 4.0 Junit4 其他依赖包 描述：JsrDAO类，在该类中使用了SpEL和spring注解12345678910111213141516171819202122232425262728293031323334package com.laowang.annotationBase;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.ImportResource;import org.springframework.stereotype.Repository;@Repository(\"dao\")@ImportResource(\"classpath*:jdbc.properties\")public class JsrDAO &#123; @Value(\"$&#123;url&#125;\")//加载配置文件中key为url的value值注入 private String url; @Value(\"$&#123;name&#125;\") private String name; @Value(\"$&#123;password&#125;\") private String password; public void save()&#123; System.out.println(\"jsr saving...\"); System.out.println(\"url: \"+url); System.out.println(\"name: \"+name); System.out.println(\"password: \"+password); &#125; public void init()&#123; System.out.println(\"init jsrDAO Bean ...\"); &#125; public void destroy()&#123; System.out.println(\"destroy jsrDAO Bean ...\"); &#125;&#125; 资源文件内容 url=http\\://localhost\\:3306/database name=root password=root JavaConfig类，Bean的装配工作12345678910111213141516package com.laowang.annotationBase;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;import org.springframework.test.context.ContextConfiguration;@Configurationpublic class JavaConfig &#123; @Bean(name=\"dao\", initMethod=\"init\", destroyMethod=\"destroy\") public JsrDAO getJseDAO()&#123; return new JsrDAO(); &#125;&#125; 测试类1234567891011121314151617181920package com.laowang.annotationBase;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=JavaConfig.class)public class TestA &#123; @Autowired private JsrDAO jsDao; @Test public void testDAO()&#123; jsDao.save(); &#125;&#125; 结果获得数据显示为 init jsrDAO Bean ... jsr saving... url: ${url} name: ${name} password: ${password} destroy jsrDAO Bean ... 问题出现在用SpEL占位符绑定bean的三个属性没有成功，正确的结果应该是这样的 init jsrDAO Bean ... jsr saving... url: http://localhost:3306/database name: root password: root destroy jsrDAO Bean ... 问题出现在哪里呢？按理说应该不会错的。于是百度、谷歌搜索，都没解决，最后去了spring官方文档看到正确使用方式 所以只需要修改JavaConfig文件就可以了，添加一行注解，变成如下： 1234567891011121314151617181920212223package com.laowang.annotationBase;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(\"classpath*:spring-annotationBase.xml\")//这个必须要引入，否者得到配置文件中的值是有问题的，有了这个可以不用在JsrDAO中重配置了，多了也无妨public class JavaConfig &#123; @Bean(name=\"dao\", initMethod=\"init\", destroyMethod=\"destroy\") public JsrDAO getJseDAO()&#123; return new JsrDAO(); &#125; @Bean public JsrService getJsrService()&#123; JsrService service =new JsrService(); service.setJsrDAO(getJseDAO()); return service; &#125; &#125; 同时再添加一个对应的xml配置文件，指定属性配置文件的位置，此时JsrDAo中属性文件位置的指定也可以不用了。下面是对应的xml文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:/properties/jdbc.properties\"/&gt;&lt;/beans&gt; PS：下面补充一点知识关于代理模式，如图 运行时注入 属性占位符（Property Placeholder） Spring 表达式语言SpEL 属性占位符（Property Placeholder） 加载资源配置文件后，通过环境对象（Environment）env获取配置文件内容，如1env.getProperty(\"jdbc.name\"); 具体使用要参考文档 解析属性占位符一般使用SpEL语言SpEL语言特性如下： 使用bean的ID来引用bean 调用方法和访问对象的属性 对值进行算术、关系和逻辑运算 正则表达式匹配 集合操作 详 “#{…}”=======表达式“${…}”=======占位符 字面常量“#{1}”=======计算结果为1 引用bean、属性和方法“#{bean}”=======引用bean“#{bean.attr}”=======计算得到（引用）bean的属性“#{systemProperties[‘jdbc.name’]}”=======通过systemProperties对象引用系统属性（个人理解为引用形同加载配置文件中的属性的值）“#{bean.method()}”=======调用bean的方法“#{bean.method()?.toUpperCase()}”=======方法返回不为空时继续调用toUpperCase()，否则不调用 在表达式中使用类型“#{T(java.lang.Math).random}”=======只能调用类的静态方法和常量 SpEL 运算符不说了 计算正则表达式：文本（matches）正则表达式“#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com’}”=======邮件验证 计算集合“#{bean.list[2].attr}”=======获取bean中结合list第3个元素的attr属性 SpEL 其他运算符 （.?[]）对集合进行过滤。[]里面是表达式“#{bean.list.?[attr eq ‘laowang’]}” .^[] 集合中查询第一个匹配项 .$[] 集合中查询最后一个匹配项","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring Bean","date":"2017-04-14T01:00:04.000Z","path":"2017/04/14/Spring-Bean/","text":"Spring Bean的相关基础知识先上图： bean的配置 Id bean的唯一标识 *必须 Class 具体实现类 *必须 Scope 作用域范围 singleton ：单例，一个bean容器只存在一份 prototype ：每次请求创建新实例，destroy方式不生效 request ：每次http请求创建一个实例且仅在当前request内有效 session ：同上 global session ：基于protlet的web中有效（portlet中定义了global session），如果在web中，同session Constructor arguments 构造器（构造函数），参数 Properties 属性 Autowiring mode 自动装配模式 lazy-initialization mode 懒加载模式 initialization/destruction method 初始化方法/销毁方法 等… … bean的作用域 singleton ：单例，一个bean容器只存在一份 prototype ：每次请求创建新实例，destroy方式不生效 request ：每次http请求创建一个实例且仅在当前request内有效 session ：同上 global session ：基于protlet的web中有效（portlet中定义了global session），如果在web中，同session bean的生命周期上图： 接下来： 定义 初始化 1.设置全局的初始化方法default-init-method或对单个bean设置init-method 2.实现org.sringframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 使用 销毁 1.设置全局的销毁方法default-destroy-method或对单个bean设置destroy-method 2.实现org.sringframework.beans.factory.DisposeableBean接口，覆盖destroy方法 bean的自动装配 Spring中提供了一些一Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应的资源。 通过Aware接口可以对spring相应资源进行操作 设置默认自动装配，spring容器中就不需要再为bean手动设置属性引用关系，容器会自动寻找和bean属性名相同的bean的id，并且自动完成bean的装配： 123456789101112 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"default-autowire=\"byName\"&gt;&lt;bean id=\"injectionDao\" class=\"com.laowang.dao.InjectionDAOImp\"/&gt;&lt;bean id=\"injectionservice\" class=\"com.laowang.service.InjectionServiceImp\"/&gt;&lt;!-- &lt;property name=\"injectiondao\" ref=\"injectionDao\"&gt;&lt;/property&gt;通过设置自动装配，就不用单独为bean装配了 --&gt;&lt;/beans&gt; Resource&amp;ResourceLoader 下面是resourceLoader resourceloader加载文件的location类型 //第一次更新。最近读了spring实战，对spring bean的配置又多了一点知识储备。 装配bean有三种机制 基于xml配置显示的装配bean 基于javaConfig的配置类(@Configuration)显示装配bean 隐式的bean发现机制和自动装配(需要@Configuration和@ComponentScan) 关于第三种机制的使用规制 12345678//spring配置之隐式bean发现和自动装配@Configuration@ComponentScan//也可用Named替换,默认扫面package包内注解//@ComponentScan(basePackages=&#123;\"com.laowang.chapter02\"&#125;)指定扫描的package//@ComponentScan(basePackageClasses=&#123;Cd.class,UseCd.class&#125;)指定扫描的类//@ImportResource(\"classpath:spring-beans.xml\")//public class Config &#123;&#125; 关于第二种机制的使用例子123456789101112131415161718192021222324@Configurationpublic class javaConfig &#123;//只是用@Bean话，bean的id将会初始化为方法名@Bean(name=\"cd\")public Cd getCd()&#123; return new Cd();&#125;//通过setter方法自动装配bean引用@Bean(name=\"useCd\")public UseCd randomMentod()&#123; UseCd useCd = new UseCd(); useCd.setCd(getCd()); return useCd;&#125;//通过构造器自动装配bean// @Bean(name=\"useCd\")// public UseCd getByConstructor()&#123;// return new UseCd(getCd());// &#125;&#125; 关于第一种使用规则就比较多了，需要的时候再搜索吧 接下来是基础的spring bean的注解 @Component 该类作为组建类，告知spring为这个类创建bean @Named//bean命名 @Configuration @ComponentScan @Bean @Import @ImportResource @Inject//注入 @Autowired @ContextConfiguration//从哪加载配置 @Repositroy （PS：下面是web.xml配置文件的详解） web.xml配置详解","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"单例模式优化详解","date":"2017-04-02T02:26:35.000Z","path":"2017/04/02/单例模式优化详解/","text":"在GoF的23种设计模式中，单例模式是比较简单的一种。然而，有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。 1. 最简单的实现 首先，能够想到的最简单的实现是，把类的构造函数写成private的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。这样，使用者就可以通过这个引用使用到这个类的实例了。 public class SingletonClass { private static final SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() { return instance; } private SingletonClass() { } } 如上例，外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 2. 性能优化——lazy loaded 上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个instance对象。如果这个创建过程很耗时，比如需要连接10000次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？ 为了解决这个问题，我们想到了新的解决方案： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。 我们来想象一下这个过程。要使用SingletonClass，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。 这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载。 3. 同步 上面的代码很清楚，也很简单。然而就像那句名言：“80%的错误都是由20%代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下： 线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败！ 解决的方法也很简单，那就是加锁： public class SingletonClass { private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 是要getInstance()加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。 4. 又是性能 上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题——synchronized修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } return instance; } private SingletonClass() { } } 首先去掉getInstance()的同步操作，然后把同步锁加载if语句上。但是这样的修改起不到任何作用：因为每次调用getInstance()的时候必然要同步，性能问题还是存在。如果……如果我们事先判断一下是不是为null再去同步呢？ public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if (instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } } 还有问题吗？首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。 这就是double-checked locking设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。 5. 从源头检查 下面我们开始说编译原理。所谓编译，就是把源代码“翻译”成目标代码——大多数是指机器代码——的过程。针对Java，它的目标代码不是本地机器代码，而是虚拟机代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程成为reorder。 要知道，JVM只是一个标准，并不是实现。JVM中并没有规定有关编译器优化的内容，也就是说，JVM实现可以自由的进行编译器优化。 下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM规范并没有规定。那么就存在这么一种情况，JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。 下面我们来考虑这么一种情况：线程A开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，A已经把instance指向了那块内存，只是还没有调用构造方法，因此B检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果B在A将instance构造完成之前就是用了这个实例，程序就会出现错误了！ 于是，我们想到了下面的代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { SingletonClass sc; synchronized (SingletonClass.class) { sc = instance; if (sc == null) { synchronized (SingletonClass.class) { if(sc == null) { sc = new SingletonClass(); } } instance = sc; } } } return instance; } private SingletonClass() { } } 我们在第一个同步块里面创建一个临时变量，然后使用这个临时变量进行对象的创建，并且在最后把instance指针临时变量的内存空间。写出这种代码基于以下思想，即synchronized会起到一个代码屏蔽的作用，同步块里面的代码和外部的代码没有联系。因此，在外部的同步块里面对临时变量sc进行操作并不影响instance，所以外部类在instance=sc;之前检测instance的时候，结果instance依然是null。 不过，这种想法完全是错误的！同步块的释放保证在此之前——也就是同步块里面——的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把instance=sc;这句移到内部同步块里面执行。这样，程序又是错误的了！ 6. 解决方案 说了这么多，难道单例没有办法在Java中实现吗？其实不然！ 在JDK 5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。 public class SingletonClass { private volatile static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } } 然而，这只是JDK1.5之后的Java的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到Java版本的影响： public class SingletonClass { private static class SingletonClassInstance { private static final SingletonClass instance = new SingletonClass(); } public static SingletonClass getInstance() { return SingletonClassInstance.instance; } private SingletonClass() { } } 在这一版本的单例模式实现代码中，我们使用了Java的静态内部类。这一技术是被JVM明确说明了的，因此不存在任何二义性。在这段代码中，因为SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。 由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是并发的，所以getInstance()也并不需要加同步。 至此，我们完整的了解了单例模式在Java语言中的时候，提出了两种解决方案。个人偏向于第二种，并且Effiective Java也推荐的这种方式。 转载自tuoni123的博客","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"spring初识","date":"2017-03-27T14:30:42.000Z","path":"2017/03/27/spring初识/","text":"Spring 概述 1. Spring 是什么Spring 是一个开源的轻量级 Java SE（ Java 标准版本）/Java EE（ Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。 Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA ），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 web 层框架 Spring MVC 、而且还能非常简单的与第三方 web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（ C/S 架构）应用程序还是 JAVA EE（ B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？ 2. Spring 能帮我们做什么2.1. Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系 传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。 2.2 Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制 当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring ，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。 2.3 Spring能非常简单的帮我们管理数据库事务 在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。 除以上之外，Spring 还可以： 与第三方数据库访问框架（如 Hibernate、JPA ）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。 与第三方 Web（如 Struts、JSF ）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 web 层搭建。 与 Java EE（如 Java Mail 、任务调度）整合，与更多技术整合（比如缓存框架）。 3. Spring 的优点3.1 关键概念 应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。 框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。 轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 POJO ： POJO （ Plain Ordinary Java Object ）简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 控制反转：即 Inversion of Control ，缩写为 IoC ，控制反转还有一个名字叫做依赖注入（ Dependency Injection ），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。 - Bean ：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。 3.2 Spring 的优点 非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 JAR 包非常小，Spring3.0.5 不到 1 M ，而且不需要依赖任何应用服务器，可以部署在任何环境（ Java SE 或 Java EE ）。 AOP： AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（ OOP ），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。 简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。 JDBC 抽象及 ORM （对象关系映射）框架支持： Spring 使 JDBC 更加容易使用；提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等；并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。 灵活的 Web 层支持： Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。 简化各种技术集成：提供对 Java Mail 、任务调度、 JMX 、 JMS 、 JNDI 、 EJB 、动态语言、远程访问、 Web Service 等的集成。 Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。 4. Spring 架构图 4.1核心容器：包括 Core 、 Beans 、 Context 、 EL 模块 Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。 Beans 模块：提供了框架的基础部分，包括控制反转（ IOC ）和依赖注入（ DI ）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。 Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、 Java EE 支持、容器生命周期、事件传播等；核心接口是 ApplicationContext 。 EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean， 它也支持列表投影、选择和一般的列表聚合等. 4.2 AOP 、 Aspects 模块： AOP 模块： Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（ aspect-oriented programming ）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。数据访问/集成模块：该模块包括了 JDBC 、 ORM 、 OXM 、 JMS 和事务管理。 事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。 JDBC 模块：提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。 ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate 、JPA 、 MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。 OXM 模块：提供了一个对 Object / XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象， Object / XML 映射实现包括 JAXB 、 Castor 、 XMLBeans 和 XStream 。 JMS 模块：用于 JMS ( Java Messaging Service )，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS ， JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Web / Remoting 模块： Web / Remoting 模块包含了 Web 、 Web-Servlet 、 Web-Struts 、 Web-Porlet 模块。 Web 模块：提供了基础的 web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（ RMI 、Hessian 、 Burlap ）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。 Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。 Web-Struts 模块：提供了与 Struts 无缝集成， Struts1.x 和 Struts2.x 都支持。 Test 模块： Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"succeed_in_build_nginx_module","date":"2017-03-22T13:31:34.000Z","path":"2017/03/22/succeed-in-build-nginx-module/","text":"开发nginx入门竟然成功了，下面就是我的路程向上图说明一下nginx模块工作流程 工具准备 ubuntu虚拟机 nginx源文件 *Note 鉴于博客是我自己看我就只是记录一些关键步骤 Nginx在Linux下的安装与运行tar -zxvf archive_name.tar.gz 解压文件命令 编译安装原文件用以下命令 ./configure --prefix=/usr/local/nginx make make install *note 这里给出编译安装nginx中使用到的命令 --prefix=指定安装目录 --add-module=连带模块一起便已安装的模块路径 模块的目录结构是module.c以及config文件 安装完成后可以直接使用下面命令启动Nginx： /usr/local/nginx/sbin/nginx Nginx默认以Deamon进程启动，输入下列命令： curl -i http://localhost/ 就可以检测Nginx是否已经成功运行。或者也可以在浏览器中输入http://localhost/，应该可以看到Nginx的欢迎页面了。启动后如果想停止Nginx可以使用： /usr/local/nginx/sbin/nginx -s stop 开发模块源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148 #include&lt;ngx_config.h&gt;#include&lt;ngx_core.h&gt;#include&lt;ngx_http.h&gt;//定义模块配置结构typedef struct&#123; ngx_str_t ed;//用于存储echo指令指定输出字符串&#125;ngx_http_echo_loc_conf_t;//函数声明static char *ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);static void *ngx_http_echo_create_loc_conf(ngx_conf_t *cf);static char *ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child);//定义指令static ngx_command_t ngx_http_echo_commands[]=&#123;&#123; ngx_string(\"echo\"), NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1, ngx_http_echo, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_echo_loc_conf_t, ed), NULL&#125;,ngx_null_command//指令数组最后一个结尾元素&#125;;//模块echo的context结构配置 static ngx_http_module_t ngx_http_echo_module_ctx=&#123; NULL, //pre configuration NULL, //post configuration NULL, //create main configuration NULL, //init main configuration NULL, //create server configuration NULL, //merge server configuration ngx_http_echo_create_loc_conf, //create location configuration ngx_http_echo_merge_loc_conf //merge location configuration&#125;;//echo模块的模块主体定义ngx_module_t ngx_http_echo_module = &#123; NGX_MODULE_V1, &amp;ngx_http_echo_module_ctx, /* module context */ ngx_http_echo_commands, /* module directives*/ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING&#125;;/**模块的handler函数编写.主要有4个职责* 读入模块配置* 处理业务功能* 产生HTTP Header* 产生HTTP body*/static ngx_int_t ngx_http_echo_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_buf_t *b; ngx_chain_t out; ngx_http_echo_loc_conf_t *elcf; elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module); if(!(r-&gt;method &amp; (NGX_HTTP_HEAD | NGX_HTTP_GET | NGX_HTTP_POST))) &#123; return NGX_HTTP_NOT_ALLOWED; &#125; r-&gt;headers_out.content_type.len = sizeof(\"text/html\")-1; r-&gt;headers_out.content_type.data = (u_char *)\"text/html\"; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = elcf-&gt;ed.len; if(r-&gt;method == NGX_HTTP_HEAD) &#123; rc = ngx_http_send_header(r); if(rc != NGX_OK) &#123; return rc; &#125; &#125; b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t)); if(b == NULL) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"Fail to allocate response buffer.\"); return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; out.buf = b; out.next = NULL; b-&gt;pos = elcf-&gt;ed.data; b-&gt;last = elcf-&gt;ed.data + (elcf-&gt;ed.len); b-&gt;memory =1; b-&gt;last_buf = 1; rc = ngx_http_send_header(r); if(rc != NGX_OK) &#123; return rc; &#125; return ngx_http_output_filter(r, &amp;out);&#125;//指令中函数指针的实现static char* ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_echo_handler; ngx_conf_set_str_slot(cf, cmd, conf); return NGX_CONF_OK;&#125;//初始化一个配置结构体static void* ngx_http_echo_create_loc_conf(ngx_conf_t *cf)&#123; ngx_http_echo_loc_conf_t *conf; conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_echo_loc_conf_t)); if(conf == NULL) &#123; return NGX_CONF_ERROR; &#125; conf-&gt;ed.len = 0; conf-&gt;ed.data = NULL; return conf;&#125;//合并配置结构体(将父类配置信息合并到此)static char* ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent,void *child)&#123; ngx_http_echo_loc_conf_t *pre = parent; ngx_http_echo_loc_conf_t *conf = child; ngx_conf_merge_str_value(conf-&gt;ed, pre-&gt;ed, \"\")//具体合并的实现是一个宏定义 return NGX_CONF_OK;&#125; Nginx模块的安装Nginx不支持动态链接模块，所以安装模块需要将模块代码与Nginx源代码进行重新编译。安装模块的步骤如下： 1、编写模块config文件，这个文件需要放在和模块源代码文件放在同一目录下。文件内容如下： ngx_addon_name=模块完整名称 HTTP_MODULES=&quot;$HTTP_MODULES 模块完整名称&quot; NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/源代码文件名&quot; 2、进入Nginx源代码，使用下面命令编译安装 ./configure --prefix=安装目录 --add-module=模块源代码文件目录 make make install 这样就完成安装了，例如，我的源代码文件放在/home/yefeng/ngxdev/ngx_http_echo下，我的config文件为： ngx_addon_name=ngx_http_echo_module HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_echo_module&quot; NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_echo_module.c&quot; 编译安装命令为： ./configure --prefix=/usr/local/nginx --add-module=/home/laowang/ngxdev/ngx_http_echo make sudo make install 这样echo模块就被安装在我的Nginx上了，下面测试一下，修改配置文件，增加以下一项配置： location /echo { echo &quot;This is my first nginx module!!!&quot;; } 然后用curl测试一下： curl -i http://localhost/echo 这里附上此次在ubuntu上用到的命令行 ps -ef |grep nginx 查看nginx的进程 nginx -s reload 重新加载nginx的配置文件 pwd 查看当前工作路径 提醒 本次实践完全是在root环境下的，整个过程很多地方都用sudo 再接再厉参考博客 nginx配置相关博客1.基本配置张龙豪的csdn 2.Nginx代理功能与负载均衡详解 3.基本配置 nginx与apache的比较","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginxNote","date":"2017-03-19T15:47:57.000Z","path":"2017/03/19/nginxNote/","text":"Nginx模块开发笔记预备知识1.C语言的结构体和预处理命令以及指针相关知识。 2.HTTP协议的基本了解。 3.Nginx的基本配置 Nginx 配置文件主要分成四部分： main（全局设置）、 server（主机设置） 、upstream（上游服务器设置）和location（URL匹配特定位置后的设置） 。 每部分包含若干个指令。 main 部分设置的指令将影响其它所有部分； server 部分的指令主要用于指定主机和端口； upstream 的指令用于设置后端服务器；location 部分用于匹配网页位置（比如， 根目录“/”,“/images” 等等） 。Location 部分会继承 server 部分的指令，而 server 部分的指令会继承 main 部分； upstream 既不继承指令也不会影响其他部分。 它有自己的特殊指令，不需要在其他地方的应用。 Nginx 模块主要有 3 种角色 handlers(处理模块) 用于处理 HTTP 请求， 然后产生输出 filters（过滤模块） 过滤 handler 产生的输出 load-balancers（负载均衡模块） 当有多于一台的后端备选服务器时， 选择一台转发 HTTP 请求 一个典型的处理周期是这样的 客户 端发送 HTTP 请求-&gt;Nginx 根据配置选择一个合适的处理模块-&gt;（如果有）负载均衡模块选择一台后端服务器，并负责完成后端的发送接收过程-&gt;处理模块进行处理并把输出缓冲放到第一个过滤模块上-&gt;第一个过滤模块处理后输出给第二个过滤模块-&gt;然后第二个过滤模块又到第三个-&gt;依此类推-&gt;最后把回复发给客户 端。 Nginx启动，关闭，重启看这个博客 Nginx模块开发入门博客比较好的一篇博客 还有一个不错的博客","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"PythonNote","date":"2017-03-19T07:00:39.000Z","path":"2017/03/19/PythonNote/","text":"python note1.Python的字符串对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： &gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;中&apos;) 20013 &gt;&gt;&gt; chr(66) &apos;B&apos; &gt;&gt;&gt; chr(25991) &apos;文&apos; 输出 &gt;&gt;&gt; &apos;\\u4e2d\\u6587&apos; &apos;中文&apos; 2.常见的占位符%d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 NOTE 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： &gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7 &apos;growth rate: 7 %&apos; 返回多个值输入 import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 输出 &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(x, y) 151.96152422706632 70.0 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 默认参数必须指向不变对象例如 def add_end(L=[]): L.append(&apos;END&apos;) return L &gt;&gt;&gt; add_end() [&apos;END&apos;, &apos;END&apos;] &gt;&gt;&gt; add_end() [&apos;END&apos;, &apos;END&apos;, &apos;END&apos;] 原因:Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 修改 def add_end(L=None): if L is None: L = [] L.append(&apos;END&apos;) return L 可变参数的函数def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，可以这样做： &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 函数小结 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 切片&gt;&gt;&gt; L = list(range(100)) &gt;&gt;&gt; L [0, 1, 2, 3, ..., 99] 前10个数： &gt;&gt;&gt; L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： &gt;&gt;&gt; L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： &gt;&gt;&gt; L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： &gt;&gt;&gt; L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list： &gt;&gt;&gt; L[:] [0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： &gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： &gt;&gt;&gt; &apos;ABCDEFG&apos;[:3] &apos;ABC&apos; &gt;&gt;&gt; &apos;ABCDEFG&apos;[::2] &apos;ACEG&apos; 迭代 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 判断一个对象是可迭代对象的方法是通过collections模块的Iterable类型判断： &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： &gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): ... print(i, value) ... 0 A 1 B 2 C 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： &gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]: ... print(x, y) ... 1 1 2 4 3 9 列表解析 &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： &gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到 &gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录 [&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] 列表生成式也可以使用两个变量来生成list： &gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; } &gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()] [&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写： &gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;] &gt;&gt;&gt; [s.lower() for s in L] [&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 函数是编程 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。 Python内建map()和reduce()函数&gt;&gt;&gt; def f(x): ... return x * x ... &gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串： &gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] 装饰器在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。 装饰器","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"梦之光芒小游戏","date":"2017-01-15T06:38:48.000Z","path":"2017/01/15/梦之光芒小游戏/","text":"第一关查看源代码即可 第二关 第三关 第四关先将string.fromCharCode()翻译过来 翻译过后能看到答案d4g","tags":[{"name":"闯关游戏","slug":"闯关游戏","permalink":"http://yoursite.com/tags/闯关游戏/"}]},{"title":"jsp传递bean到servlet为null","date":"2016-12-12T15:34:10.000Z","path":"2016/12/12/jsp传递bean到servlet为null/","text":"jsp 中使用 1&lt;jsp:useBean id=\"user\" scope=\"request\" class=\"bean.User\"&gt; id是bean的引用名（绑定的名字） scope作用域（request|session|application） class对象所属类的完全限定名 问题： 在jsp中使用上述方法，在servlet中获得的user 为null原因分析 jsp的编译完以后就是servlet，显示完成那个jsp页面完了以后，就已经是一次request了。因此在jsp中创建一个scope=”request”的bean只能在 jsp中、或者是jsp通过传递方式给其他对象才能用这个bean即使你jsp中提交的表单给另外一个servlet的，那已经是第二次request。对应的解决就是更改作用域范围为session。 jsp页面中javabean的属性设置是依靠 jsp engine帮你实现的。如果表单提交到了servlet，意味着你就失去了jsp engine这个优势，需要自己set这些属性。 如果提交给servlet，是在servlet中set这些属性。那么形成表单的页面的jsp文件中就没有必要用javabean。javabean的用法是在提交以后的那个页面，而非形成表单的页面，除非要显示或者计算用途 解决方法 方法一 设置作用域scope为session 在servlet中设置user的各个属性 在servlet中再将user绑定到session，在后就可以转发 方法二 在表单提交中不是用useBean","tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"tomcatstartup","date":"2016-11-28T14:58:14.000Z","path":"2016/11/28/tomcatstartup/","text":"启动tomcat报错Error deploying configuration descriptor 导致原因 servlet创建时有 @WebServlet(“/UploadFile”) 这个注解导致报错 报错图片","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"tomcatinstall","date":"2016-10-02T01:29:17.000Z","path":"2016/10/02/tomcatinstall/","text":"安装和配置tomcat的小坑1.下载tomcat去这个tomcat.apache.org网址下载core的zip包 2.安装tomcat将下载的tomcat解压缩就安装成功了 3.1windows下tomcat的配置设置环境变量 CATALINA_HOME C:\\Users\\wangyonghao8\\Desktop\\java文档\\tomcat\\apache-tomcat-7.0.72 note * 1.注意环境变量设置的路径是安装tomcat的路径，不是其下的bin目录 2.必须确保jdk配置成功才能成功启动tomcat 3.2eclipse下安装tomcata.打开eclipsewindows -&gt; preference -&gt; server -&gt; runtime Environment b.选择add按钮，选择对应的tomcat安装，然后选择Edit选择tomcat # 安装目录 # 4。启动tomcatwidows下直接到安装目录下的bin目录中打开startup.bat即可 eclipse中打开server视图，右击选择启动按钮即可","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"java中的堆和栈","date":"2016-09-25T01:24:03.000Z","path":"2016/09/25/java中的堆和栈/","text":"Java栈与堆—-对这两个概念的不明好久，终于找到一篇好文，拿来共享 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：复制内容到剪贴板代码:int a = 3;int b = 3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 4. String是一个特殊的包装类数据。即可以用String str = new String(“abc”);的形式来创建，也可以用String str = “abc”；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = “abc”；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。 关于String str = “abc”的内部工作。Java内部将此语句转化为以下几个步骤： (1)先定义一个名为str的对String类的对象引用变量：String str； (2)在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并返回o的地址。 (3)将str指向对象o的地址。 值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！ 为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”;System.out.println(str1==str2); //true注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。 我们再来更进一步，将以上代码改成：复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”;str1 = “bcd”;System.out.println(str1 + “,” + str2); //bcd, abcSystem.out.println(str1==str2); //false这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。 再修改原来代码：复制内容到剪贴板代码:String str1 = “abc”;String str2 = “abc”; str1 = “bcd”; String str3 = str1;System.out.println(str3); //bcd String str4 = “bcd”;System.out.println(str1 == str4); //truestr3这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。 我们再接着看以下的代码。复制内容到剪贴板代码:String str1 = new String(“abc”);String str2 = “abc”;System.out.println(str1==str2); //false 创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 String str1 = “abc”;String str2 = new String(“abc”);System.out.println(str1==str2); //false创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。 7. 结论与建议： (1)我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。 (2)使用String str = “abc”；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 (3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 (4)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JavaThread","date":"2016-09-25T01:09:39.000Z","path":"2016/09/25/JavaThread/","text":"Java 线程池的原理与实现最近在学习线程池、内存控制等关于提高程序运行性能方面的编程技术，在网上看到有一哥们写得不错，故和大家一起分享。 [分享]Java 线程池的原理与实现 这几天主要是狂看源程序，在弥补了一些以前知识空白的同时，也学会了不少新的知识（比如 NIO），或者称为新技术吧。线程池就是其中之一，一提到线程，我们会想到以前《操作系统》的生产者与消费者，信号量，同步控制等等。一提到池，我们会想到数据库连接池，但是线程池又如何呢？ 建议：在阅读本文前，先理一理同步的知识，特别是syncronized同步关键字的用法。关于我对同步的认识，要缘于大三年的一本书，书名好像是 Java 实战，这本书写得实在太妙了，真正的从理论到实践，从截图分析到.class字节码分析。哇，我想市场上很难买到这么精致的书了。作为一个Java爱好者，我觉得绝对值得一读。我对此书印象最深之一的就是：equal()方法，由浅入深，经典！还有就是同步了，其中提到了我的几个编程误区，以前如何使用同步提高性能等等，通过学习，使我对同步的认识进一步加深。 简单介绍 创建线程有两种方式：继承Thread或实现Runnable。Thread实现了Runnable接口，提供了一个空的run()方法，所以不论是继承Thread还是实现Runnable，都要有自己的run()方法。 一个线程创建后就存在，调用start()方法就开始运行（执行run()方法），调用wait进入等待或调用sleep进入休眠期，顺利运行完毕或休眠被中断或运行过程中出现异常而退出。 wait和sleep比较： sleep方法有：sleep(long millis)，sleep(long millis, long nanos)，调用sleep方法后，当前线程进入休眠期，暂停执行，但该线程继续拥有监视资源的所有权。到达休眠时间后线程将继续执行，直到完成。若在休眠期另一线程中断该线程，则该线程退出。 wait方法有：wait()，wait(long timeout)，wait(long timeout, long nanos)，调用wait方法后，该线程放弃监视资源的所有权进入等待状态； wait()：等待有其它的线程调用notify()或notifyAll()进入调度状态，与其它线程共同争夺监视。wait()相当于wait(0)，wait(0, 0)。 wait(long timeout)：当其它线程调用notify()或notifyAll()，或时间到达timeout亳秒，或有其它某线程中断该线程，则该线程进入调度状态。 wait(long timeout, long nanos)：相当于wait(1000000*timeout + nanos)，只不过时间单位为纳秒。 线程池： 多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。 假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。 一个线程池包括以下四个基本组成部分： 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务； 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子： 假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324/** 线程池类，工作线程作为其内部类 **/package org.ymcn.util;import java.util.Collections;import java.util.Date;import java.util.LinkedList;import java.util.List;import org.apache.log4j.Logger;/*** 线程池* 创建线程池，销毁线程池，添加新任务** @author obullxl*/public final class ThreadPool &#123; private static Logger logger = Logger.getLogger(ThreadPool.class); private static Logger taskLogger = Logger.getLogger(\"TaskLogger\"); private static boolean debug = taskLogger.isDebugEnabled(); // private static boolean debug = taskLogger.isInfoEnabled(); /* 单例 */ private static ThreadPool instance = ThreadPool.getInstance(); public static final int SYSTEM_BUSY_TASK_COUNT = 150; /* 默认池中线程数 */ public static int worker_num = 5; /* 已经处理的任务数 */ private static int taskCounter = 0; public static boolean systemIsBusy = false; private static List&lt;Task&gt; taskQueue = Collections .synchronizedList(new LinkedList&lt;Task&gt;()); /* 池中的所有线程 */ public PoolWorker[] workers; private ThreadPool() &#123; workers = new PoolWorker[5]; for (int i = 0; i &lt; workers.length; i++) &#123; workers[i] = new PoolWorker(i); &#125; &#125; private ThreadPool(int pool_worker_num) &#123; worker_num = pool_worker_num; workers = new PoolWorker[worker_num]; for (int i = 0; i &lt; workers.length; i++) &#123; workers[i] = new PoolWorker(i); &#125; &#125; public static synchronized ThreadPool getInstance() &#123; if (instance == null) return new ThreadPool(); return instance; &#125; /** * 增加新的任务 * 每增加一个新任务，都要唤醒任务队列 * @param newTask */ public void addTask(Task newTask) &#123; synchronized (taskQueue) &#123; newTask.setTaskId(++taskCounter); newTask.setSubmitTime(new Date()); taskQueue.add(newTask); /* 唤醒队列, 开始执行 */ taskQueue.notifyAll(); &#125; logger.info(\"Submit Task&lt;\" + newTask.getTaskId() + \"&gt;: \" + newTask.info()); &#125; /** * 批量增加新任务 * @param taskes */ public void batchAddTask(Task[] taskes) &#123; if (taskes == null || taskes.length == 0) &#123; return; &#125; synchronized (taskQueue) &#123; for (int i = 0; i &lt; taskes.length; i++) &#123; if (taskes[i] == null) &#123; continue; &#125; taskes[i].setTaskId(++taskCounter); taskes[i].setSubmitTime(new Date()); taskQueue.add(taskes[i]); &#125; /* 唤醒队列, 开始执行 */ taskQueue.notifyAll(); &#125; for (int i = 0; i &lt; taskes.length; i++) &#123; if (taskes[i] == null) &#123; continue; &#125; logger.info(\"Submit Task&lt;\" + taskes[i].getTaskId() + \"&gt;: \" + taskes[i].info()); &#125; &#125; /** * 线程池信息 * @return */ public String getInfo() &#123; StringBuffer sb = new StringBuffer(); sb.append(\"\\nTask Queue Size:\" + taskQueue.size()); for (int i = 0; i &lt; workers.length; i++) &#123; sb.append(\"\\nWorker \" + i + \" is \" + ((workers[i].isWaiting()) ? \"Waiting.\" : \"Running.\")); &#125; return sb.toString(); &#125; /** * 销毁线程池 */ public synchronized void destroy() &#123; for (int i = 0; i &lt; worker_num; i++) &#123; workers[i].stopWorker(); workers[i] = null; &#125; taskQueue.clear(); &#125; /** * 池中工作线程 * * @author obullxl */ private class PoolWorker extends Thread &#123; private int index = -1; /* 该工作线程是否有效 */ private boolean isRunning = true; /* 该工作线程是否可以执行新任务 */ private boolean isWaiting = true; public PoolWorker(int index) &#123; this.index = index; start(); &#125; public void stopWorker() &#123; this.isRunning = false; &#125; public boolean isWaiting() &#123; return this.isWaiting; &#125; /** * 循环执行任务 * 这也许是线程池的关键所在 */ public void run() &#123; while (isRunning) &#123; Task r = null; synchronized (taskQueue) &#123; while (taskQueue.isEmpty()) &#123; try &#123; /* 任务队列为空，则等待有新任务加入从而被唤醒 */ taskQueue.wait(20); &#125; catch (InterruptedException ie) &#123; logger.error(ie); &#125; &#125; /* 取出任务执行 */ r = (Task) taskQueue.remove(0); &#125; if (r != null) &#123; isWaiting = false; try &#123; if (debug) &#123; r.setBeginExceuteTime(new Date()); taskLogger.debug(\"Worker&lt;\" + index + \"&gt; start execute Task&lt;\" + r.getTaskId() + \"&gt;\"); if (r.getBeginExceuteTime().getTime() - r.getSubmitTime().getTime() &gt; 1000) taskLogger.debug(\"longer waiting time. \" + r.info() + \",&lt;\" + index + \"&gt;,time:\" + (r.getFinishTime().getTime() - r .getBeginExceuteTime().getTime())); &#125; /* 该任务是否需要立即执行 */ if (r.needExecuteImmediate()) &#123; new Thread(r).start(); &#125; else &#123; r.run(); &#125; if (debug) &#123; r.setFinishTime(new Date()); taskLogger.debug(\"Worker&lt;\" + index + \"&gt; finish task&lt;\" + r.getTaskId() + \"&gt;\"); if (r.getFinishTime().getTime() - r.getBeginExceuteTime().getTime() &gt; 1000) taskLogger.debug(\"longer execution time. \" + r.info() + \",&lt;\" + index + \"&gt;,time:\" + (r.getFinishTime().getTime() - r .getBeginExceuteTime().getTime())); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(e); &#125; isWaiting = true; r = null; &#125; &#125; &#125; &#125;&#125;/** 任务接口类 **/package org.ymcn.util;import java.util.Date;/*** 所有任务接口* 其他任务必须继承访类** @author obullxl*/public abstract class Task implements Runnable &#123; // private static Logger logger = Logger.getLogger(Task.class); /* 产生时间 */ private Date generateTime = null; /* 提交执行时间 */ private Date submitTime = null; /* 开始执行时间 */ private Date beginExceuteTime = null; /* 执行完成时间 */ private Date finishTime = null; private long taskId; public Task() &#123; this.generateTime = new Date(); &#125; /** * 任务执行入口 */ public void run() &#123; /** * 相关执行代码 * * beginTransaction(); * * 执行过程中可能产生新的任务 subtask = taskCore(); * * commitTransaction(); * * 增加新产生的任务 ThreadPool.getInstance().batchAddTask(taskCore()); */ &#125; /** * 所有任务的核心 所以特别的业务逻辑执行之处 * * @throws Exception */ public abstract Task[] taskCore() throws Exception; /** * 是否用到数据库 * * @return */ protected abstract boolean useDb(); /** * 是否需要立即执行 * * @return */ protected abstract boolean needExecuteImmediate(); /** * 任务信息 * * @return String */ public abstract String info(); public Date getGenerateTime() &#123; return generateTime; &#125; public Date getBeginExceuteTime() &#123; return beginExceuteTime; &#125; public void setBeginExceuteTime(Date beginExceuteTime) &#123; this.beginExceuteTime = beginExceuteTime; &#125; public Date getFinishTime() &#123; return finishTime; &#125; public void setFinishTime(Date finishTime) &#123; this.finishTime = finishTime; &#125; public Date getSubmitTime() &#123; return submitTime; &#125; public void setSubmitTime(Date submitTime) &#123; this.submitTime = submitTime; &#125; public long getTaskId() &#123; return taskId; &#125; public void setTaskId(long taskId) &#123; this.taskId = taskId; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"thread线程","slug":"thread线程","permalink":"http://yoursite.com/tags/thread线程/"}]},{"title":"eclipseEditorAsisst","date":"2016-09-16T02:30:50.000Z","path":"2016/09/16/eclipseEditorAsisst/","text":"在eclipse中编辑java项目的编辑帮助和一些热键1.增强Eclipse（MyEclipse）输入代码提示功能(1). 打开Eclipse，选择打开” Window －－ Preferences”。 (2). 在目录树上选择”Java－－Editor－－Content Assist”，在右侧的”Auto-Activation”找到”Auto Activation triggers for java”选项。默认触发代码提示的就是”.”这个符号。(3). 在”Auto Activation triggers for java”选项中，在”.”后加上qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM字母。然后”Apply”，点击”OK” 2.一些热键(1)Ctrl+Space 说明:内容助理。提供对方法,变量,参数,javadoc等得提示,应运在多种场合,总之需要提示的时候可先按此快捷键。注:避免输入法的切换设置与此设置冲突 (2)Ctrl+Shift+Space 说明:变量提示 (3)Ctrl+/ 说明:添加/消除//注释,在eclipse2.0中,消除注释为Ctrl+\\ (4)Ctrl+Shift+/ 说明:添加/ /注释 (5)Ctrl+Shift+\\ 说明:消除/ /注释 (6)Ctrl+Shift+F 说明:自动格式化代码 (7)Ctrl+1 说明:批量修改源代码中的变量名,此外还可用在catch块上. (8)Ctril+F6 说明:界面切换 (9)Ctril+Shift+M 说明:查找所需要得包 (10)Ctril+Shift+O 说明:自动引入所需要得包 (11)Ctrl+Alt+S 说明:源代码得快捷菜单。其中的Generate getters and setters 和 Surround with try/catchblock比较常用.建议把它们添加为快捷键.快捷键设置在windows-&gt;preferences-&gt;Workbench-&gt;Keys 2. 快捷键列表编辑作用域 功能 快捷键 行 删除一行 Ctrl+D 全局 查找并替换 Ctrl+F 文本编辑器 查找上一个 Ctrl+Shift+K 文本编辑器 查找下一个 Ctrl+K 全局 撤销 Ctrl+Z 全局 复制 Ctrl+C 全局 恢复上一个选择 Alt+Shift+↓ 全局 剪切 Ctrl+X 全局 快速修正 Ctrl1+1 全局 内容辅助 Alt+/ 全局 全部选中 Ctrl+A 全局 删除 Delete 全局 上下文信息 Alt+？Alt+Shift+?Ctrl+Shift+Space Java编辑器 显示工具提示描述 F2 Java编辑器 选择封装元素 Alt+Shift+↑ Java编辑器 选择上一个元素 Alt+Shift+← Java编辑器 选择下一个元素 Alt+Shift+→ 文本编辑器 增量查找 Ctrl+J 文本编辑器 增量逆向查找 Ctrl+Shift+J 全局 粘贴 Ctrl+V 全局 重做 Ctrl+Y 查看作用域 功能 快捷键 全局 放大 Ctrl+= 全局 缩小 Ctrl+- 窗口作用域 功能 快捷键 全局 激活编辑器 F12 全局 切换编辑器 Ctrl+Shift+W 全局 上一个编辑器 Ctrl+Shift+F6 全局 上一个视图 Ctrl+Shift+F7 全局 上一个透视图 Ctrl+Shift+F8 全局 下一个编辑器 Ctrl+F6 全局 下一个视图 Ctrl+F7 全局 下一个透视图 Ctrl+F8 文本编辑器 显示标尺上下文菜单 Ctrl+W 全局 显示视图菜单 Ctrl+F10 全局 显示系统菜单 Alt+- 导航作用域 功能 快捷键 Java编辑器 打开结构 Ctrl+F3 全局 打开类型 Ctrl+Shift+T 全局 打开类型层次结构 F4 全局 打开声明 F3 全局 打开外部javadoc Shift+F2 全局 打开资源 Ctrl+Shift+R 全局 后退历史记录 Alt+← 全局 前进历史记录 Alt+→ 全局 上一个 Ctrl+, 全局 下一个 Ctrl+. Java编辑器 显示大纲 Ctrl+O 全局 在层次结构中打开类型 Ctrl+Shift+H 全局 转至匹配的括号 Ctrl+Shift+P 全局 转至上一个编辑位置 Ctrl+Q Java编辑器 转至上一个成员 Ctrl+Shift+↑ Java编辑器 转至下一个成员 Ctrl+Shift+↓ 文本编辑器 转至行 Ctrl+L 搜索作用域 功能 快捷键 全局 出现在文件中 Ctrl+Shift+U 全局 打开搜索对话框 Ctrl+H 全局 工作区中的声明 Ctrl+G 全局 工作区中的引用 Ctrl+Shift+G 文本编辑作用域 功能 快捷键 文本编辑器 改写切换 Insert 文本编辑器 上滚行 Ctrl+↑ 文本编辑器 下滚行 Ctrl+↓ 文件作用域 功能 快捷键 全局 保存 Ctrl+X Ctrl+S 全局 打印 Ctrl+P 全局 关闭 Ctrl+F4 全局 全部保存 Ctrl+Shift+S 全局 全部关闭 Ctrl+Shift+F4 全局 属性 Alt+Enter 全局 新建 Ctrl+N 项目作用域 功能 快捷键 全局 全部构建 Ctrl+B 源代码 作用域 功能 快捷键 Java编辑器 格式化 Ctrl+Shift+F Java编辑器 取消注释 Ctrl+\\ Java编辑器 注释 Ctrl+/ Java编辑器 添加导入 Ctrl+Shift+M Java编辑器 组织导入 Ctrl+Shift+O Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。 运行作用域 功能 快捷键 全局 单步返回 F7 全局 单步跳过 F6 全局 单步跳入 F5 全局 单步跳入选择 Ctrl+F5 全局 调试上次启动 F11 全局 继续 F8 全局 使用过滤器单步执行 Shift+F5 全局 添加/去除断点 Ctrl+Shift+B 全局 显示 Ctrl+D 全局 运行上次启动 Ctrl+F11 全局 运行至行 Ctrl+R 全局 执行 Ctrl+U重构作用域 功能 快捷键 全局 撤销重构 Alt+Shift+Z 全局 抽取方法 Alt+Shift+M 全局 抽取局部变量 Alt+Shift+L 全局 内联 Alt+Shift+I 全局 移动 Alt+Shift+V 全局 重命名 Alt+Shift+R 全局 重做 Alt+Shift+Y","tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"operate","date":"2016-09-14T08:49:00.000Z","path":"2016/09/14/operate/","text":"###python字符串中字符大小写的变换： S.lower() 小写 S.upper() 大写 S.swapcase() 大小写互换 S.capitalize() 首字母大写 String.capwords(S)这是模块中的方法。它把S用split()函数分开，然后用capitalize()把首字母变成大写，最后用join()合并到一起 S.title()只有首字母大写，其余为小写，模块中没有这个方法字符串在输出时的对齐： S.ljust(width,[fillchar])输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。 S.rjust(width,[fillchar])右对齐 S.center(width, [fillchar])中间对齐 S.zfill(width)把S变成width长，并在右对齐，不足部分用0补足","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"error","date":"2016-05-21T13:50:36.000Z","path":"2016/05/21/error/","text":"IndentationError: expected an indented block 解决方法：此时只需要在print前面加tab键就可以了，即：后面需要缩进。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"php_install","date":"2016-05-14T09:22:42.000Z","path":"2016/05/14/php-install/","text":"PHPstorm安装问题 1.安装phpStorm 2.打开并运行一个小程序 3.出现了这么一个问题 4.回头看看phpstorm编辑器，发现这个错误 接下来开始解决 首先点击file-&gt;settings-&gt;language &amp; framework-&gt;php 或则如图直接进入 然后点击 找到php解释器路径（我的方案是wamp中的php解释器），如图 点击 apply ok 即可 最后 当你运行时，浏览器中出现 说明已经成功了 tips：建议预先安装wamp集成包","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"install wampServer","date":"2016-05-03T05:00:20.000Z","path":"2016/05/03/install-wampServer/","text":"The solution to the problems when Installed wampServer on win8.1.一.when launched it,a problem show up: *** ERROR *** The PHP configuration loaded file is: - should be: D:/wamp/bin/apache/apache2.4.17/bin/php.ini or d:/wamp/bin/php/php5.6.15/phpforapache.ini here is the solution:请先退出wampServer 1.以管理员身份运行cmd.exe 进入C:\\windows\\system32\\ -&gt; 找到cmd.exe -&gt; 右击并且以管理员身份运行 2.键入命令进入安装apache的目录 我的是 D:\\wamp\\bin\\apache\\apache2.4.17\\bin 3.创建软连接 mklink php.ini d:\\wamp\\bin\\php\\php5.6.15\\phpForApache.ini 成功之后你会看到 为php.ini &lt;&lt; === &gt;&gt; d:\\wamp\\bin\\php\\php5.6.15\\phpForApache.ini 创建的符号链接","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"linux foundation","date":"2016-05-01T15:47:21.000Z","path":"2016/05/01/linux-foundation/","text":"linux特点1.所有内容以文件存储 2.区分大小写 3.不区分拓展名 4.win下程序不能直接在linux上安装和运行 为什么服务器端用linux服务器端要求:安全，稳定 优势一：字符界面占用的系统资源更少 优势二：字符界面减少错误和被攻击的可能性 磁盘分区（把大硬盘分成小的逻辑分区）1.主分区最多只有4个 2.拓展分区：最多只有一个 1.主分区和拓展分区最多有四个 2.不能写入数据，只能包含逻辑分区 3.格式化：写入文件系统 设置， 数据块（block） 【表】节点（node） 4.分区设备文件名：（给每个分区定义设备文件名） 5.挂载：（给每个分区分配挂载点）//分区，目录结合叫挂载 pwd 显示当前目录 tab 目录补全和命令补全 date 显示系统时间 ls -i [文件一] [文件二] 查看文件的inode信息 ctrl+L 清屏 linux命令目录处理命令 0.ls -l 详细信息 可简写为 ll 1.mkdir -p [目录名] -p递归创建，如 Japanese/erpha 一次创建完成 2.cd [目录] cd ~ 进入当前用户的家目录。和直接使用cd一样 cd - 进入上次目录 cd .. 进入上一级目录 cd . 进入当前目录 3.rmdir [空白目录] rm -rf [任意目录] -r删目录-f强制 4.cp 复制 cp -r 复制目录 cp -p 连带文件属性复制 cp -d 若原文件是链接文件，则复制连接属性 cp -a 相当于 -pdr 5.mv [原文见或目录] [目标目录（同目录下为改名，不同目录下为剪切)] 剪切或改名命令 6.ln -s [原文件绝对路径] [目标文件] 连接处理命令(-s 创建软链接，不加的话就是创建硬链接) 软连接类似于win下的快捷方式 有自己的icode 搜索命令 1.locate [文件名]文件搜索命令 在/var/lib/mlocate后台数据库中搜索，该数据库一天更新一次，当然也可以用updatedb强制更新该数据库 2.whereis与which搜索命令的命令-b只看在哪-m只看帮助文档 which查到的是位置和别名 echo $PATH 3.find [搜索范围] -name(/-iname/-user/-nouser/-mtime/-ctime/-atime/-size/-inum)[搜索条件] 按照文件名搜索 完全匹配，可以用通配符模糊查询 4.grep (-v排除指定字符串/-i忽略大小写)[选项] 字符串 文件名 正则表达式包含匹配 帮助命令 1.man 命令 man -f 命令=whatis 命令 （查看命令拥有哪个级别的帮助） man -k 命令=apropos 命令 （查看和命令相关的所有帮助） 2.其他帮助命令 命令 -help选项帮助 help shell内部命令 eg：help cd and help whereis cd info 命令 -回车 进入子帮助页面（带有*好标记） -u 进入上层页面 -n 进入下一个帮助小节 -p 进入上一个帮助小节 -q 退出 压缩与解压缩命令 .zip zip/unzip (-r压缩目录的选项) 压缩文件名 源文件 .gz gzip （-r压缩目录下的所有子文件） 源文件 压缩完源文件将消失 gunzip （-r解压缩目录） 压缩包 .bz2 bzip2 原文件 原文件会消失，想保留原文件加-r选项 不能压缩目录 bunzip2 压缩包 加-k选项的话，压缩包会保留 tar 打包命令（常用） tar -cvf 打包文件名 源文件-c打包-v显示过程-f指定打包后的文件名 tar -xvf 打包文件名 -x解打包-t为查看压缩包内内容 tar -zcvf 压缩包名.tar.gz 原文件 -z压缩为.tar.gz格式 -c换成-x为解压 tar -jcvf 压缩包名.tar.bz2 原文件 压缩包名可以指定路径 tar -jxvf 压缩包名 -C 目录 解压到指定目录 .tar.gz .tar.bz2 关机与重启命令 shutdown [选项] 时间 [&amp;] -c取消前一个关机命令-h关机-r重启&amp;后台启动 下面一般会又损害 关机 halt poweroff init 0 重启 init 6 reboot 退出登录（注销） logout runlevel当前系统运行级别查询init 级别 cat /etc/inittab 修改系统默认运行级别 其他命令 1.挂载命令 mount查看已经挂载的分区 mount -a 依据/etc/fstab/的内容，自动挂载。 1挂载命令格式 mount [-t文件系统] [-o特殊选项] 设备文件名 挂载点 2挂在光盘 mkdir /mut/cdrom/ 创建挂载点（挂在店必须是空目录） mount -t iso9660 /dev/sr0 /mnt/cdrom/ =mount /dev/sr0 /mnt/cdrom/ 简化版 3卸载命令 umount 设备文件名或挂载点 4U盘挂载 fdisk -l 查看系统中已经识别的硬盘 mount -t vfat /dev/sdb1/mnt/usb/ linux默认不支持BTFS文件系统 2.用户登录查看和用户交互命令 w who 简单显示 last 查询当前登录和过去登陆的用户信息 lastlog 查看所有用户的最后一次登录时间 shell基础 shell：命令行解释器 脚本执行方法 echo [选项] [要输出的内容] -e 支持转义字符 echo “zifuchuan ” 输出字符串 echo -e “\\e[1;31m 字符串 \\e[0m” 开启颜色显示颜色值为31m 写脚本 vi 文件名 进入编辑后开始的第一行必须是#!/bin/bash 注释用# 脚本执行 赋予执行权限，直接执行 chmod 755 文件名 ./文件名（相对路径，也可以写绝对路径） 通过bash调用执行脚本 bash 文件名(加路径) bash的基本功能 1.命令别名与快捷键 查看别名 alias 查看系统中已经生效的别名 设定别名 alias 别名=&apos;准确格式的原命令&apos; （注销就不起作用了，永久设置的话，要写入环境变量配置文件 vim ~/.bashrc 也可以直接写入bashrc文件，在source就行了） 删除别名 unalias 命令生效顺序 含路径命令 &gt; 别名 &gt; bash内部命令 &gt; 外部$PATH命令 2.历史命令 history 查看输入过的所有命令 !n 重复执行第n条命令 !!重复执行最后一个命令 !字符串 重复执行以字符串开始的命令 history [选项] [历时命令保存文件] -w强制写入当前命令的历史记录-c清除所有命令 3.输出重定向 指定输出内容的地方 &gt; 覆盖方式 &gt;&gt; 追加的方式 2&gt;&gt;标准错误输出（追加，2&gt;覆盖） *命令 &gt;&gt; 文件 2&gt;&amp;1 如果命令是正确的，则直接写入文件中，错误的，就把报错写入到文件中 *命令 &amp;&gt;&gt;文件名 或则命令 &amp;&gt;文件名 *命令 &gt;&gt; 文件1 2&gt;&gt;文件2 正确信息保存到文件1中错误信息保存到文件2中 输入重定向 wc [选项] [文件名] 最后按下ctrl+d/w/l统计 4.多命令顺序执行 ；顺序执行分号两边的命令 &amp;&amp;两边命令都正确才执行 ||两边命令只要有一个正确的就执行 | 管道符 用法 命令1 | 命令2,命令1的结果作为命令2的操作对象 eg:ls -l /etc | more netstat -an | grep &quot;ESTABLISHED&quot; 查询网络连接中包含ESTA...的行 5.shell中特殊符号 通配符 ? * [] 其他特殊符号 常用快捷键 ctrl + c 强制终止当前命令 ctrl + l 清屏 ctrl + a 光标移动到命令行首 ctrl + e 光标移动到命令行尾 ctrl + u 从光标所在位置删除到行首 ctrl + z 把命令放入后台 ctrl + r 在历时命令中搜索 17/4/17日更新 几张linux命令图 ps： 具体视频请参看imooc中linux达人","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"博客链接","date":"2016-04-22T04:03:36.000Z","path":"2016/04/22/links/","text":"博客 1.Java paradise的博客 2.hexo的详解3.moxfive的博客 4.Gevin 5.开涛的博客 开源 1.美团github 概念理解博文 1.web.xml配置中classpath:和classpath*:的区别 2.码农网 用法+教程 1.SpringMVC&lt;from:form&gt;表单标签和&lt;input&gt;表单标签简介 2.spring mvc教程 3.mysql添加用户，修改密码，授权","tags":[{"name":"links","slug":"links","permalink":"http://yoursite.com/tags/links/"}]},{"title":"初次部署hexo到github上","date":"2016-04-20T09:49:21.000Z","path":"2016/04/20/my-first-post/","text":"部署hexo到github上时遇到了很多问题，搞了两天 一. 错误归结于 deploy： type：github//错误的（有些网上的教程不知道为什么在我这里错了） type：git//正确的（stackflow上查到的） 还要提醒一点repository的设置必须是ssh的协议的url，不是http协议的url 二.我的设置如下 repository: git@github.com:tellen7/tellen7.github.io.git branch: master//部署到master分支上 NOTE 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 三.配置时区错误 timezone: 如果设置不对，将提示这种错误 TypeError: Cannot read property ‘offset’ of null 并且提示 See http://momentjs.com/timezone/docs/#/data-loading/. 所以我没有设置 _ warming 1.配置hexo根目录下的_config.yml文件时要参看官方文档，不要轻易随便改动配置文件 2.如果希望将_config.yml文件中的subtitle:属性值中文内容显示必须将 _config.yml文件编码形式改为 UTF-8 格式。如果用记事本编辑，在 另存为 步骤中修改编码。不过推荐用sublime 打开配置为文件，其支持语法高亮。 3.关于主题配置请参看文档。说明一点，当使用git clone时，应该在 hexo根目录 下打开git bash。应用主题时只要在_config.yml文件中更改 theme:就行了。 4.如果想给自己的文章加标签，那么可以直接在文章中的tags:出添加你想要的标签，不过要切记tags:和标签之间要留一个空格，否者会出现如下错误 YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1: 一定要留空格！！！！这是一个大坑！ 5.其他错误看看这篇博客能不能帮到。 tips 执行hexo New [layout] “new post name”之后会在hexo根目录下的source文件中的_post中生成New post name的markdown文件，用能编辑markdown文件的编辑器打开编辑好保存之后在hexo g(生成静态网页)-&gt;hexo s[可有可无] (localhost:4000中查看效果，不满意再编辑，编辑好之后再 hexo g)-&gt;hexo d(部署到github上) 关于hexo s命令行，可以在markdown编辑文件中直接察看文档效果就行了，完全可以忽略。但是，当你月到错误时，在这个环节查看错无也是必不可少的！ 这里给出了更多主题，知乎上的和github上的。喜欢哪个就用哪个吧。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]